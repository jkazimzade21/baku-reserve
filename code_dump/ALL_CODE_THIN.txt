# Curated code dump
# Generated: 2025-10-23T14:29:00-05:00

===== FILE: backend/app/__init__.py =====

===== FILE: backend/app/availability.py =====
from datetime import datetime, time, timedelta, date
from typing import Any, Dict, List

RES_DURATION = timedelta(minutes=90)
INTERVAL = timedelta(minutes=30)
OPEN = time(10, 0)
CLOSE = time(23, 0)

def _overlaps(a_start: datetime, a_end: datetime, b_start: datetime, b_end: datetime) -> bool:
    return not (a_end <= b_start or a_start >= b_end)

def _iso_parse(s: str) -> datetime:
    return datetime.fromisoformat(s)

def availability_for_day(restaurant: Any, party_size: int, day: date, db) -> Dict[str, Any]:
    """
    Returns: {"slots":[{"start":iso,"end":iso,"available_table_ids":[...],"count":N}, ...]}
    Only considers reservations with status == "booked".
    """
    rid = str(restaurant.get("id"))

    # Tables that fit the party
    tables: List[Dict[str, Any]] = []
    for area in (restaurant.get("areas") or []):
        for t in (area.get("tables") or []):
            cap = int(t.get("capacity", 2) or 2)
            if cap >= party_size:
                tables.append(t)

    # Existing booked reservations for that date, same restaurant
    todays = []
    for r in db.reservations.values():
        if str(r.get("restaurant_id")) != rid:
            continue
        if r.get("status", "booked") != "booked":
            continue
        try:
            rs = _iso_parse(str(r["start"]))
            re = _iso_parse(str(r["end"]))
        except Exception:
            continue
        if rs.date() == day:
            todays.append({"table_id": str(r.get("table_id")), "start": rs, "end": re})

    slots = []
    cur = datetime.combine(day, OPEN)
    last_start = datetime.combine(day, CLOSE) - RES_DURATION

    while cur <= last_start:
        slot_end = cur + RES_DURATION
        free_ids: List[str] = []
        for t in tables:
            tid = str(t.get("id"))
            taken = any(
                (rt["table_id"] == tid) and _overlaps(cur, slot_end, rt["start"], rt["end"])
                for rt in todays
            )
            if not taken:
                free_ids.append(tid)

        slots.append({
            "start": cur.isoformat(timespec="seconds"),
            "end": slot_end.isoformat(timespec="seconds"),
            "available_table_ids": free_ids,
            "count": len(free_ids),
        })
        cur += INTERVAL

    return {"slots": slots}

===== FILE: backend/app/config.py =====
import os
from pathlib import Path

# App version
APP_VERSION = "0.1.1"

# Base dir (this file's folder is backend/app/)
BASE_DIR = Path(__file__).resolve().parent

# Where to persist data (reservations.json). Can be overridden with env:
#   DATA_DIR="/some/dir" uvicorn app.main:app --reload ...
DATA_DIR = Path(os.environ.get("DATA_DIR", str(BASE_DIR / "data")))
DATA_DIR.mkdir(parents=True, exist_ok=True)

# CORS: comma-separated list of origins. Default "*" (allow all).
# Example: ALLOW_ORIGINS="http://localhost:8081,http://192.168.0.148:19000"
_allow = os.environ.get("ALLOW_ORIGINS", "*")
ALLOW_ORIGINS = [o.strip() for o in _allow.split(",") if o.strip()] or ["*"]

===== FILE: backend/app/main.py =====
from fastapi import FastAPI, HTTPException, Query
from uuid import UUID
from typing import Optional, Any, Dict
from datetime import date, datetime

from .schemas import RestaurantListItem
from .models import ReservationCreate, Reservation

from .storage import DB
from .utils import add_cors
from .availability import availability_for_day

app = FastAPI(title="Baku Reserve API", version="0.1.0")
add_cors(app)

@app.get("/health")
def health():
    return {"ok": True, "service": "baku-reserve", "version": "0.1.0"}

# ---------- helpers ----------
def get_attr(o: Any, key: str, default=None):
    if isinstance(o, dict):
        return o.get(key, default)
    return getattr(o, key, default)

def restaurant_to_list_item(r: Any) -> Dict[str, Any]:
    return {
        "id": str(get_attr(r, "id")),
        "name": get_attr(r, "name"),
        "cuisine": list(get_attr(r, "cuisine", []) or []),
        "city": get_attr(r, "city"),
        "cover_photo": (get_attr(r, "cover_photo") or (get_attr(r, "photos", []) or [None])[0]),
    }

def restaurant_to_detail(r: Any) -> Dict[str, Any]:
    areas = []
    for a in (get_attr(r, "areas", []) or []):
        tables = []
        for t in (get_attr(a, "tables", []) or []):
            tables.append({
                "id": str(get_attr(t, "id")),
                "name": get_attr(t, "name") or f"Table {str(get_attr(t, 'id'))[:6]}",
                "capacity": int(get_attr(t, "capacity", 2) or 2),
            })
        areas.append({
            "id": str(get_attr(a, "id")),
            "name": get_attr(a, "name") or "Area",
            "tables": tables,
        })
    return {
        "id": str(get_attr(r, "id")),
        "name": get_attr(r, "name"),
        "cuisine": list(get_attr(r, "cuisine", []) or []),
        "city": get_attr(r, "city"),
        "address": get_attr(r, "address") or "",
        "phone": get_attr(r, "phone") or "",
        "photos": list(get_attr(r, "photos", []) or []),
        "areas": areas,
    }

def rec_to_reservation(rec: Dict[str, Any]) -> Reservation:
    return Reservation(
        id=str(rec["id"]),
        restaurant_id=str(rec["restaurant_id"]),
        table_id=str(rec.get("table_id")) if rec.get("table_id") else None,
        party_size=int(rec["party_size"]),
        start=datetime.fromisoformat(str(rec["start"])) if isinstance(rec["start"], str) else rec["start"],
        end=datetime.fromisoformat(str(rec["end"])) if isinstance(rec["end"], str) else rec["end"],
        guest_name=str(rec.get("guest_name", "")),
        guest_phone=str(rec.get("guest_phone", "")) if rec.get("guest_phone") else None,
        status=str(rec.get("status", "booked")),
    )

# ---------- root redirect to docs ----------
@app.get("/", include_in_schema=False)
def root_redirect():
    # Redirect to docs for convenience when you hit the base URL in a browser.
    return {"detail": "See /docs"}, 307

# ---------- endpoints ----------
@app.get("/restaurants", response_model=list[RestaurantListItem])
def list_restaurants(q: Optional[str] = None):
    items = DB.list_restaurants(q)
    return [restaurant_to_list_item(r) for r in items]

@app.get("/restaurants/{rid}")
def get_restaurant(rid: UUID):
    r = DB.get_restaurant(str(rid))
    if not r:
        raise HTTPException(404, "Restaurant not found")
    return restaurant_to_detail(r)

@app.get("/restaurants/{rid}/floorplan")
def get_floorplan(rid: UUID):
    r = DB.get_restaurant(str(rid))
    if not r:
        raise HTTPException(404, "Restaurant not found")
    canvas = {"width": 1000, "height": 1000}
    areas = []
    for a in (get_attr(r, "areas", []) or []):
        tables = []
        for t in (get_attr(a, "tables", []) or []):
            tables.append({
                "id": str(get_attr(t, "id")),
                "name": get_attr(t, "name"),
                "capacity": int(get_attr(t, "capacity", 2) or 2),
                "position": get_attr(t, "position"),
                "shape": get_attr(t, "shape"),
            })
        areas.append({"id": str(get_attr(a, "id")), "name": get_attr(a, "name"), "tables": tables})
    return {"canvas": canvas, "areas": areas}

@app.post("/reservations", response_model=Reservation, status_code=201)
def create_reservation(payload: ReservationCreate):
    try:
        res = DB.create_reservation(payload)
        return res
    except HTTPException as e:
        raise e
    except ValueError as e:
        raise HTTPException(409, str(e))

@app.post("/reservations/{resid}/cancel", response_model=Reservation)
def soft_cancel_reservation(resid: UUID):
    rec = DB.set_status(str(resid), "cancelled")
    if not rec:
        raise HTTPException(404, "Reservation not found")
    return rec_to_reservation(rec)

@app.post("/reservations/{resid}/confirm", response_model=Reservation)
def confirm_reservation(resid: UUID):
    rec = DB.set_status(str(resid), "booked")
    if not rec:
        raise HTTPException(404, "Reservation not found")
    return rec_to_reservation(rec)

@app.delete("/reservations/{resid}", response_model=Reservation)
def hard_delete_reservation(resid: UUID):
    r = DB.cancel_reservation(str(resid))
    if not r:
        raise HTTPException(404, "Reservation not found")
    return rec_to_reservation(r)

@app.get("/restaurants/{rid}/availability")
def availability(rid: UUID, date_: date = Query(..., alias="date"), party_size: int = 2):
    r = DB.get_restaurant(str(rid))
    if not r:
        raise HTTPException(404, "Restaurant not found")
    return availability_for_day(r, party_size, date_, DB)

@app.get("/reservations")
def list_reservations():
    return DB.list_reservations()

===== FILE: backend/app/models.py =====
from __future__ import annotations
from pydantic import BaseModel, Field, field_validator
from typing import List, Optional, Literal
from datetime import datetime

# --- Tables & floorplan (string IDs so our demo IDs work) ---
class Table(BaseModel):
    id: str
    name: Optional[str] = None
    capacity: int = 2

class Area(BaseModel):
    id: str
    name: Optional[str] = None
    tables: List[Table] = Field(default_factory=list)

# --- Restaurant list/detail ---
class RestaurantListItem(BaseModel):
    id: str
    name: str
    cuisine: List[str] = Field(default_factory=list)
    city: str
    cover_photo: Optional[str] = None

class Restaurant(BaseModel):
    id: str
    name: str
    cuisine: List[str] = Field(default_factory=list)
    city: str = "Baku"
    address: Optional[str] = None
    phone: Optional[str] = None
    photos: List[str] = Field(default_factory=list)
    areas: List[Area] = Field(default_factory=list)

# --- Reservations ---
class ReservationCreate(BaseModel):
    restaurant_id: str
    party_size: int
    start: datetime
    end: datetime
    guest_name: str
    guest_phone: Optional[str] = None
    table_id: Optional[str] = None

    @field_validator("party_size")
    @classmethod
    def _party_positive(cls, v: int) -> int:
        if v < 1:
            raise ValueError("party_size must be >= 1")
        return v

    @field_validator("end")
    @classmethod
    def _end_after_start(cls, v: datetime, info):
        start = info.data.get("start")
        if isinstance(start, datetime) and v <= start:
            raise ValueError("end must be after start")
        return v

class Reservation(BaseModel):
    id: str
    restaurant_id: str
    party_size: int
    start: datetime
    end: datetime
    guest_name: str
    guest_phone: Optional[str] = None
    table_id: Optional[str] = None
    status: Literal["booked", "cancelled"] = "booked"

===== FILE: backend/app/schemas.py =====
from pydantic import BaseModel, Field, field_validator
from typing import List, Optional, Literal, Tuple
from datetime import datetime
from uuid import UUID, uuid4

class Table(BaseModel):
    id: UUID = Field(default_factory=uuid4)
    name: str
    capacity: int
    position: Tuple[int, int] | None = None
    shape: Literal["circle", "rect"] = "circle"

class Area(BaseModel):
    id: UUID = Field(default_factory=uuid4)
    name: str
    tables: List[Table] = Field(default_factory=list)

class Restaurant(BaseModel):
    id: UUID = Field(default_factory=uuid4)
    name: str
    cuisine: List[str] = Field(default_factory=list)
    city: str = "Baku"
    address: Optional[str] = None
    phone: Optional[str] = None
    photos: List[str] = Field(default_factory=list)
    areas: List[Area] = Field(default_factory=list)

class RestaurantListItem(BaseModel):
    id: UUID
    name: str
    cuisine: List[str]
    city: str
    cover_photo: Optional[str] = None

class ReservationCreate(BaseModel):
    restaurant_id: UUID
    party_size: int
    start: datetime
    end: datetime
    guest_name: str
    guest_phone: Optional[str] = None
    table_id: Optional[UUID] = None

    @field_validator("party_size")
    @classmethod
    def _party_positive(cls, v: int) -> int:
        if v < 1:
            raise ValueError("party_size must be >= 1")
        return v

    @field_validator("end")
    @classmethod
    def _end_after_start(cls, v: datetime, info):
        start = info.data.get("start")
        if isinstance(start, datetime) and v <= start:
            raise ValueError("end must be after start")
        return v

class Reservation(BaseModel):
    id: UUID = Field(default_factory=uuid4)
    restaurant_id: UUID
    party_size: int
    start: datetime
    end: datetime
    guest_name: str
    guest_phone: Optional[str] = None
    table_id: Optional[UUID] = None
    status: Literal["booked", "cancelled"] = "booked"

===== FILE: backend/app/seed.py =====
from .schemas import Restaurant, Area, Table
from .storage import DB

def seed():
    if DB.restaurants:
        return

    def t(name, cap, x, y):
        return Table(name=name, capacity=cap, position=(x,y))

    sahil = Restaurant(
        name="SAHiL Bar & Restaurant",
        cuisine=["Azerbaijani","Seafood"],
        city="Baku",
        address="Neftchilar Ave, Seaside Boulevard",
        phone="+994 12 000 0000",
        photos=["https://picsum.photos/seed/sahil/800/500"],
        areas=[
            Area(name="Main Hall", tables=[t("T1",4,200,300), t("T2",2,350,320), t("T3",4,480,310)]),
            Area(name="Terrace", tables=[t("W1",2,700,220), t("W2",4,820,260)]),
        ]
    )

    gunaydin = Restaurant(
        name="Günaydın Steakhouse (Bulvar)",
        cuisine=["Steakhouse","Turkish"],
        city="Baku",
        address="Bulvar Mall",
        phone="+994 12 111 1111",
        photos=["https://picsum.photos/seed/gunaydin/800/500"],
        areas=[
            Area(name="Steak Hall", tables=[t("S1",2,180,600), t("S2",4,260,640), t("S3",6,360,620)]),
            Area(name="Window", tables=[t("W1",2,700,650), t("W2",2,780,660)]),
        ]
    )

    mari = Restaurant(
        name="Mari Vanna",
        cuisine=["Eastern European","Russian"],
        city="Baku",
        address="Old City",
        phone="+994 12 222 2222",
        photos=["https://picsum.photos/seed/marivanna/800/500"],
        areas=[
            Area(name="Parlor", tables=[t("P1",2,240,200), t("P2",4,340,240)]),
            Area(name="Garden", tables=[t("G1",2,720,300), t("G2",4,820,320)]),
        ]
    )

    for r in (sahil, gunaydin, mari):
        DB.add_restaurant(r)

===== FILE: backend/app/settings.py =====
from __future__ import annotations
from pydantic_settings import BaseSettings, SettingsConfigDict
from pydantic import AnyHttpUrl, field_validator
from typing import List, Optional
from pathlib import Path

class Settings(BaseSettings):
    model_config = SettingsConfigDict(env_file=".env", env_file_encoding="utf-8", extra="ignore")

    # whether to expose the debug config endpoint
    DEBUG: bool = True

    # persistence directory (defaults to app/data)
    DATA_DIR: Optional[Path] = None

    # CORS allow origins (comma-separated). Default "*" for dev.
    CORS_ALLOW_ORIGINS: str = "*"

    @property
    def allow_origins(self) -> List[str]:
        s = (self.CORS_ALLOW_ORIGINS or "").strip()
        if s == "" or s == "*":
            return ["*"]
        return [part.strip() for part in s.split(",") if part.strip()]

    @property
    def data_dir(self) -> Path:
        # default to <this file>/data when not set
        if self.DATA_DIR:
            return Path(self.DATA_DIR).expanduser().resolve()
        return (Path(__file__).resolve().parent / "data").resolve()

settings = Settings()
# make sure directory exists when imported
settings.data_dir.mkdir(parents=True, exist_ok=True)

===== FILE: backend/app/storage.py =====
from __future__ import annotations

import json
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional
from uuid import uuid4

from fastapi import HTTPException
from .models import Reservation, ReservationCreate

DATA_DIR = Path(__file__).resolve().parent / "data"
DATA_DIR.mkdir(parents=True, exist_ok=True)
RES_PATH = DATA_DIR / "reservations.json"

def _iso(dt: datetime) -> str:
    return dt.isoformat(timespec="seconds")

def _parse_iso(s: str) -> datetime:
    return datetime.fromisoformat(s)

class Database:
    """
    Demo DB:
      - Restaurants seeded here with stable ids.
      - Reservations persist to app/data/reservations.json
    """
    def __init__(self) -> None:
        # --- restaurants ---
        self.restaurants: Dict[str, Dict[str, Any]] = {
            "fc34a984-0b39-4f0a-afa2-5b677c61f044": {
                "id": "fc34a984-0b39-4f0a-afa2-5b677c61f044",
                "name": "SAHiL Bar & Restaurant",
                "cuisine": ["Azerbaijani", "Seafood"],
                "city": "Baku",
                "address": "Seaside Boulevard, Baku",
                "phone": "+994 12 000 00 00",
                "photos": ["https://picsum.photos/seed/sahil/800/500"],
                "cover_photo": "https://picsum.photos/seed/sahil/800/500",
                "areas": [
                    {
                        "id": "a-sahil-main",
                        "name": "Main Hall",
                        "tables": [
                            {"id": "e5c360cf-31df-4276-841e-8cd720b5942c", "name": "T1", "capacity": 2},
                            {"id": "cc67ebfe-9fad-427f-87c1-d591304fcce5", "name": "T2", "capacity": 2},
                            {"id": "40ec9ced-a11f-4009-899c-7b2d4216dea3", "name": "T3", "capacity": 4},
                            {"id": "b79563ac-0f21-4b3a-9b50-c2b6ba2a3b18", "name": "T4", "capacity": 4},
                            {"id": "9e5f3998-67d7-4a81-a816-109aec7bdeec", "name": "T5", "capacity": 6},
                        ],
                    }
                ],
            },
            "e43356ca-448a-4257-a76c-716b9f13937b": {
                "id": "e43356ca-448a-4257-a76c-716b9f13937b",
                "name": "Günaydın Steakhouse (Bulvar)",
                "cuisine": ["Steakhouse", "Turkish"],
                "city": "Baku",
                "address": "Bulvar Mall, Baku",
                "phone": "+994 12 111 11 11",
                "photos": ["https://picsum.photos/seed/gunaydin/800/500"],
                "cover_photo": "https://picsum.photos/seed/gunaydin/800/500",
                "areas": [
                    {
                        "id": "a-gunaydin-main",
                        "name": "Main Hall",
                        "tables": [
                            {"id": "f1e1b8e1-aaaa-4b11-9aaa-111111111111", "name": "A1", "capacity": 2},
                            {"id": "f1e1b8e1-bbbb-4b22-9bbb-222222222222", "name": "A2", "capacity": 4},
                            {"id": "f1e1b8e1-cccc-4b33-9ccc-333333333333", "name": "A3", "capacity": 6},
                        ],
                    }
                ],
            },
            "7cb45fee-78d6-46cf-a9fd-a8299e47e4fa": {
                "id": "7cb45fee-78d6-46cf-a9fd-a8299e47e4fa",
                "name": "Mari Vanna",
                "cuisine": ["Eastern European", "Russian"],
                "city": "Baku",
                "address": "Old City, Baku",
                "phone": "+994 12 222 22 22",
                "photos": ["https://picsum.photos/seed/marivanna/800/500"],
                "cover_photo": "https://picsum.photos/seed/marivanna/800/500",
                "areas": [
                    {
                        "id": "a-marivanna-main",
                        "name": "Main Hall",
                        "tables": [
                            {"id": "mvt-1", "name": "M1", "capacity": 2},
                            {"id": "mvt-2", "name": "M2", "capacity": 4},
                            {"id": "mvt-3", "name": "M3", "capacity": 6},
                        ],
                    }
                ],
            },
        }

        self.reservations: Dict[str, Dict[str, Any]] = {}
        self._load()

    # -------- helpers --------
    def _tables_for_restaurant(self, rid: str) -> List[Dict[str, Any]]:
        r = self.restaurants.get(rid)
        tables: List[Dict[str, Any]] = []
        if not r:
            return tables
        for area in (r.get("areas") or []):
            for t in (area.get("tables") or []):
                tables.append(t)
        return tables

    def _table_lookup(self, rid: str) -> Dict[str, Dict[str, Any]]:
        return {str(t["id"]): t for t in self._tables_for_restaurant(rid)}

    @staticmethod
    def _overlap(a_start: datetime, a_end: datetime, b_start: datetime, b_end: datetime) -> bool:
        return not (a_end <= b_start or b_end <= a_start)

    # -------- restaurants --------
    def list_restaurants(self, q: Optional[str] = None) -> List[Dict[str, Any]]:
        items = list(self.restaurants.values())
        if q:
            qlow = q.lower()
            items = [
                r for r in items
                if qlow in r["name"].lower()
                or any(qlow in c.lower() for c in r.get("cuisine", []))
                or qlow in r.get("city", "").lower()
            ]
        return [
            {
                "id": r["id"],
                "name": r["name"],
                "cuisine": r["cuisine"],
                "city": r["city"],
                "cover_photo": r.get("cover_photo") or (r["photos"][0] if r.get("photos") else ""),
            }
            for r in items
        ]

    def get_restaurant(self, rid: str) -> Optional[Dict[str, Any]]:
        return self.restaurants.get(str(rid))

    # -------- reservations --------
    def list_reservations(self) -> List[Dict[str, Any]]:
        return list(self.reservations.values())

    def create_reservation(self, payload: ReservationCreate) -> Reservation:
        rid = str(payload.restaurant_id)

        if payload.party_size < 1:
            raise HTTPException(status_code=422, detail="party_size must be >= 1")
        start = payload.start if isinstance(payload.start, datetime) else _parse_iso(str(payload.start))
        end = payload.end if isinstance(payload.end, datetime) else _parse_iso(str(payload.end))
        if end <= start:
            raise HTTPException(status_code=422, detail="end must be after start")

        if rid not in self.restaurants:
            raise HTTPException(status_code=404, detail="Restaurant not found")

        tables_by_id = self._table_lookup(rid)
        # resolve table
        if payload.table_id:
            tid = str(payload.table_id)
            if tid not in tables_by_id:
                raise HTTPException(status_code=422, detail="table_id does not belong to restaurant")
            if tables_by_id[tid].get("capacity", 1) < payload.party_size:
                raise HTTPException(status_code=422, detail="party_size exceeds table capacity")
            table_id = tid
        else:
            table_id = None
            candidates = sorted(tables_by_id.values(), key=lambda t: t.get("capacity", 2))
            for t in candidates:
                if t.get("capacity", 2) >= payload.party_size:
                    table_id = str(t["id"])
                    break
            if not table_id and candidates:
                table_id = str(candidates[-1]["id"])

        # conflict check (booked only)
        for r in self.reservations.values():
            if str(r["restaurant_id"]) != rid:
                continue
            if r.get("status", "booked") != "booked":
                continue
            if table_id and r.get("table_id") and str(r["table_id"]) != table_id:
                continue
            rs = _parse_iso(r["start"]) if isinstance(r["start"], str) else r["start"]
            re = _parse_iso(r["end"]) if isinstance(r["end"], str) else r["end"]
            if self._overlap(start, end, rs, re):
                raise HTTPException(status_code=409, detail="Selected table/time is already booked")

        new_id = str(uuid4())
        rec = {
            "id": new_id,
            "restaurant_id": rid,
            "table_id": table_id,
            "party_size": payload.party_size,
            "start": _iso(start),
            "end": _iso(end),
            "guest_name": payload.guest_name,
            "guest_phone": payload.guest_phone or "",
            "status": "booked",
        }
        self.reservations[new_id] = rec
        self._save()

        return Reservation(**{**rec, "start": start, "end": end})

    def set_status(self, resid: str, status: str) -> Optional[Dict[str, Any]]:
        if resid not in self.reservations:
            return None
        if status not in ("booked", "cancelled"):
            raise HTTPException(status_code=422, detail="invalid status")
        self.reservations[resid]["status"] = status
        self._save()
        return self.reservations[resid]

    def cancel_reservation(self, resid: str) -> Optional[Dict[str, Any]]:
        # Hard delete (used by existing DELETE route)
        out = self.reservations.pop(str(resid), None)
        if out is not None:
            self._save()
        return out

    # -------- persistence --------
    def _save(self) -> None:
        data = {
            "reservations": [
                {
                    **{k: v for k, v in r.items() if k not in ("start", "end")},
                    "start": r["start"] if isinstance(r["start"], str) else _iso(r["start"]),
                    "end": r["end"] if isinstance(r["end"], str) else _iso(r["end"]),
                }
                for r in self.reservations.values()
            ]
        }
        RES_PATH.write_text(json.dumps(data, ensure_ascii=False, indent=2))

    def _load(self) -> None:
        if not RES_PATH.exists():
            return
        try:
            raw = json.loads(RES_PATH.read_text() or "{}")
        except Exception:
            self.reservations = {}
            return

        cleaned: Dict[str, Dict[str, Any]] = {}
        for r in raw.get("reservations", []):
            try:
                rid = str(r.get("id") or uuid4())
                rest_id = str(r["restaurant_id"])
                start = _parse_iso(str(r["start"]))
                end = _parse_iso(str(r["end"]))
                if end <= start:
                    continue
                party = int(r["party_size"])
                if party < 1:
                    continue
                status = r.get("status", "booked")
                if status not in ("booked", "cancelled"):
                    status = "booked"
                cleaned[rid] = {
                    "id": rid,
                    "restaurant_id": rest_id,
                    "table_id": r.get("table_id"),
                    "party_size": party,
                    "start": _iso(start),
                    "end": _iso(end),
                    "guest_name": str(r.get("guest_name", "")),
                    "guest_phone": str(r.get("guest_phone", "")),
                    "status": status,
                }
            except Exception:
                continue
        self.reservations = cleaned

# Single instance
DB = Database()

===== FILE: backend/app/utils.py =====
from fastapi.middleware.cors import CORSMiddleware
from .settings import settings

def add_cors(app):
    app.add_middleware(
        CORSMiddleware,
        allow_origins=settings.allow_origins,
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
        expose_headers=["*"],
    )

===== FILE: backend/backend_smoketest.sh =====
#!/usr/bin/env bash
set -u

### CONFIG #####################################################################
BASE="${BASE:-http://192.168.0.148:8000}"
TEST_DATE="${TEST_DATE:-2025-10-23}"   # change if you want to test another day
NAME_PREFIX="SMOKE_$(date +%s)_"
JQ_BIN="${JQ_BIN:-jq}"

### REQUIREMENTS ###############################################################
command -v curl >/dev/null || { echo "[FATAL] curl required"; exit 1; }
command -v ${JQ_BIN} >/dev/null || { echo "[FATAL] jq required"; exit 1; }

### HARNESS ####################################################################
fail=0; pass=0
log()   { printf "%b\n" "$*"; }
ok()    { pass=$((pass+1)); log "✅  $*"; }
bad()   { fail=$((fail+1)); log "❌  $*"; }
sep()   { printf "\n===== %s =====\n" "$*"; }

# curl wrapper that captures HTTP code and body safely
req() {
  local method="$1"; shift
  local url="$1"; shift
  local data="${1:-}"
  local tmp_b="$(mktemp)"; local code

  if [[ -z "$data" ]]; then
    code=$(curl -sS -o "$tmp_b" -w "%{http_code}" -X "$method" "$url" -H "Accept: application/json")
  else
    code=$(curl -sS -o "$tmp_b" -w "%{http_code}" -X "$method" "$url" \
      -H "Accept: application/json" -H "Content-Type: application/json" --data "$data")
  fi
  echo "$code $tmp_b"
}

expect_code() {
  local want="$1"; local got="$2"
  if [[ "$want" == "$got" ]]; then return 0; fi
  # allow ranges like 4xx
  if [[ "$want" =~ x$ ]]; then
    local pfx="${want%x}"
    [[ "${got:0:1}" == "$pfx" ]] && return 0
  fi
  return 1
}

# delete all reservations whose guest_name starts with NAME_PREFIX
cleanup_smoke_reservations() {
  local code tmp out
  read -r code tmp < <(req GET "$BASE/reservations")
  out="$(cat "$tmp")"
  if ! expect_code 200 "$code"; then bad "GET /reservations ($code)"; return; fi
  local ids
  ids=$(echo "$out" | ${JQ_BIN} -r --arg pfx "$NAME_PREFIX" '.[] | select(.guest_name|startswith($pfx)) | .id')
  if [[ -z "$ids" ]]; then ok "No lingering $NAME_PREFIX reservations"; return; fi
  while IFS= read -r rid; do
    [[ -z "$rid" ]] && continue
    read -r code tmp < <(req DELETE "$BASE/reservations/$rid")
    if expect_code 200 "$code"; then ok "DELETE /reservations/$rid"; else bad "DELETE /reservations/$rid ($code)"; fi
  done <<< "$ids"
}

### DISCOVER DATA ##############################################################
sep "A0. Discover restaurants"
read -r code tmp < <(req GET "$BASE/restaurants")
if ! expect_code 200 "$code"; then bad "GET /restaurants ($code)"; exit 1; fi
out="$(cat "$tmp")"

# Prefer SAHiL; else pick first
RID=$(echo "$out" | ${JQ_BIN} -r '
  (map(select(.name=="SAHiL Bar & Restaurant"))[0].id) // (.[0].id)
')
if [[ -z "$RID" || "$RID" == "null" ]]; then bad "No restaurant found"; exit 1; fi
ok "Selected restaurant: $RID"

read -r code tmp < <(req GET "$BASE/restaurants/$RID")
if ! expect_code 200 "$code"; then bad "GET /restaurants/$RID ($code)"; exit 1; fi
RJSON="$(cat "$tmp")"

# classify tables by capacity
T2_IDS=$(echo "$RJSON" | ${JQ_BIN} -r '.areas[].tables[] | select(.capacity==2) | .id')
T4_IDS=$(echo "$RJSON" | ${JQ_BIN} -r '.areas[].tables[] | select(.capacity==4) | .id')
T6_IDS=$(echo "$RJSON" | ${JQ_BIN} -r '.areas[].tables[] | select(.capacity>=6) | .id')

T2_ONE=$(echo "$T2_IDS" | head -n1)
T4_ONE=$(echo "$T4_IDS" | head -n1)
T6_ONE=$(echo "$T6_IDS" | head -n1)

[[ -n "$T2_ONE" ]] && ok "Found 2-top: $T2_ONE" || bad "No 2-top table"
[[ -n "$T4_ONE" ]] && ok "Found 4-top: $T4_ONE" || bad "No 4-top table"
[[ -n "$T6_ONE" ]] && ok "Found 6-top+: $T6_ONE" || bad "No 6-top+ table"

sep "A1. Baseline availability"
read -r code tmp < <(req GET "$BASE/restaurants/$RID/availability?date=$TEST_DATE&party_size=2")
if expect_code 200 "$code"; then
  AJSON="$(cat "$tmp")"
  SLOTS_COUNT=$(echo "$AJSON" | ${JQ_BIN} '.slots | length')
  if [[ "$SLOTS_COUNT" -gt 0 ]]; then ok "Availability has $SLOTS_COUNT slots"; else bad "No slots returned"; fi
else
  bad "GET availability ($code)"
fi

### CLEAN START ###############################################################
sep "A2. Pre-run cleanup"
cleanup_smoke_reservations

### HELPERS FOR BOOKING #######################################################
book() {
  # args: table_id start end party_size name
  local tid="$1" s="$2" e="$3" ps="$4" name="$5"
  local payload
  payload=$(cat <<JSON
{
  "restaurant_id":"$RID",
  "party_size": $ps,
  "start":"$s",
  "end":"$e",
  "guest_name":"$name",
  "guest_phone":"+1555555",
  "table_id":"$tid"
}
JSON
)
  read -r code tmp < <(req POST "$BASE/reservations" "$payload")
  echo "$code $(cat "$tmp")"
}

first_slot_for_party() {
  local ps="$1"
  read -r code tmp < <(req GET "$BASE/restaurants/$RID/availability?date=$TEST_DATE&party_size=$ps")
  if ! expect_code 200 "$code"; then echo ""; return; fi
  cat "$tmp" | ${JQ_BIN} -r '.slots[0] | [.start,.end] | @tsv'
}

first_slot_and_table_for_party() {
  local ps="$1"
  read -r code tmp < <(req GET "$BASE/restaurants/$RID/availability?date=$TEST_DATE&party_size=$ps")
  if ! expect_code 200 "$code"; then echo ""; return; fi
  cat "$tmp" | ${JQ_BIN} -r '.slots[0] | "\(.start)\t\(.end)\t\(.available_table_ids[0])"'
}

reappears_in_slot() {
  # args: start table_id party_size
  local s="$1" tid="$2" ps="$3"
  read -r code tmp < <(req GET "$BASE/restaurants/$RID/availability?date=$TEST_DATE&party_size=$ps")
  if ! expect_code 200 "$code"; then echo "ERR"; return; fi
  cat "$tmp" | ${JQ_BIN} -r --arg s "$s" --arg tid "$tid" '
    .slots[] | select(.start==$s) | (.available_table_ids | index($tid)) | if .==null then "NO" else "YES" end
  '
}

### B. VALID RESERVATION CYCLE #################################################
sep "B. Valid cycle: create -> list -> availability -> delete"
IFS=$'\t' read -r S1 E1 TID1 < <(first_slot_and_table_for_party 2)
if [[ -z "${S1:-}" || -z "${TID1:-}" ]]; then bad "Could not pick first slot/table"; else ok "Picked slot $S1..$E1 table $TID1"; fi

read -r code body < <(book "$TID1" "$S1" "$E1" 2 "${NAME_PREFIX}CYCLE1")
if expect_code 201 "$code"; then ok "POST /reservations (created)"; else bad "POST /reservations ($code): $body"; fi

# list
read -r code tmp < <(req GET "$BASE/reservations")
if expect_code 200 "$code"; then
  RID1=$(cat "$tmp" | ${JQ_BIN} -r --arg name "${NAME_PREFIX}CYCLE1" '.[] | select(.guest_name==$name) | .id' | head -n1)
  [[ -n "$RID1" ]] && ok "Reservation listed: $RID1" || bad "Reservation not in list"
else
  bad "GET /reservations ($code)"
fi

# ensure table removed from that slot
R=$(reappears_in_slot "$S1" "$TID1" 2)
if [[ "$R" == "NO" ]]; then ok "Booked table removed from availability"; else bad "Booked table still appears in availability"; fi

# delete it
if [[ -n "${RID1:-}" ]]; then
  read -r code tmp < <(req DELETE "$BASE/reservations/$RID1")
  expect_code 200 "$code" && ok "DELETE /reservations/$RID1" || bad "DELETE /reservations/$RID1 ($code)"
fi

### C. OVERLAP VALIDATION (same table, same time) ##############################
sep "C. Overlap: identical slot on same table"
IFS=$'\t' read -r S2 E2 TID2 < <(first_slot_and_table_for_party 2)
read -r cA bA < <(book "$TID2" "$S2" "$E2" 2 "${NAME_PREFIX}OVL1")
if expect_code 201 "$cA"; then ok "Initial booking OK"; else bad "Initial booking failed ($cA)"; fi

read -r cB bB < <(book "$TID2" "$S2" "$E2" 2 "${NAME_PREFIX}OVL2")
if expect_code 4x "$cB"; then ok "Double-book rejected ($cB)"; else bad "Double-book NOT rejected ($cB)"; fi

# cleanup
RID_OVL=$(echo "$bA" | ${JQ_BIN} -r '.id // empty')
[[ -n "$RID_OVL" ]] && read -r code tmp < <(req DELETE "$BASE/reservations/$RID_OVL") && expect_code 200 "$code" && ok "Cleaned overlap booking" || true

### D. PARTIAL OVERLAPS ########################################################
sep "D. Partial overlap: consecutive overlapping windows"
# pick two consecutive windows (slots[1] and slots[2]) on same table if possible
read -r code tmp < <(req GET "$BASE/restaurants/$RID/availability?date=$TEST_DATE&party_size=2")
if expect_code 200 "$code"; then
  S10=$(cat "$tmp" | ${JQ_BIN} -r '.slots[1].start')
  E10=$(cat "$tmp" | ${JQ_BIN} -r '.slots[1].end')
  T10=$(cat "$tmp" | ${JQ_BIN} -r '.slots[1].available_table_ids[0]')
  S11=$(cat "$tmp" | ${JQ_BIN} -r '.slots[2].start')
  E11=$(cat "$tmp" | ${JQ_BIN} -r '.slots[2].end')
  T11="$T10"  # try same table to force overlap
  if [[ "$S10" != "null" && -n "$T10" && "$S11" != "null" ]]; then
    read -r c1 b1 < <(book "$T10" "$S10" "$E10" 2 "${NAME_PREFIX}PART1")
    if expect_code 201 "$c1"; then ok "Booked PART1"; else bad "PART1 failed ($c1)"; fi
    read -r c2 b2 < <(book "$T11" "$S11" "$E11" 2 "${NAME_PREFIX}PART2")
    if expect_code 4x "$c2"; then ok "Overlapping PART2 rejected"; else bad "Overlapping PART2 NOT rejected ($c2)"; fi
    # cleanup PART1
    RIDP=$(echo "$b1" | ${JQ_BIN} -r '.id // empty')
    [[ -n "$RIDP" ]] && read -r code tmp < <(req DELETE "$BASE/reservations/$RIDP") && expect_code 200 "$code" && ok "Cleaned PART1" || true
  else
    bad "Could not derive overlapping windows"
  fi
else
  bad "GET availability for partial overlap ($code)"
fi

### E. CAPACITY & PARTY SIZE ###################################################
sep "E1. Capacity: 6 people on 2-top should fail"
# Use a valid window for party_size=6 then force a 2-top table
IFS=$'\t' read -r S6 E6 T6AV < <(first_slot_and_table_for_party 6)
if [[ -z "${S6:-}" ]]; then
  ok "No 6-person slots; capacity rules implicitly hold (skipping forced fail)"
else
  if [[ -n "${T2_ONE:-}" ]]; then
    read -r c b < <(book "$T2_ONE" "$S6" "$E6" 6 "${NAME_PREFIX}CAP_BAD")
    expect_code 4x "$c" && ok "Rejected 6 on 2-top ($c)" || bad "Accepted 6 on 2-top ($c)"
  else
    bad "No 2-top to test capacity rejection"
  fi
fi

sep "E2. Valid 4 on 4-top then 4 on 2-top should fail"
IFS=$'\t' read -r S4 E4 T4AV < <(first_slot_and_table_for_party 4)
if [[ -n "${T4_ONE:-}" && -n "${S4:-}" ]]; then
  read -r c1 b1 < <(book "$T4_ONE" "$S4" "$E4" 4 "${NAME_PREFIX}CAP_GOOD4")
  expect_code 201 "$c1" && ok "Booked 4 on 4-top" || bad "Failed to book 4 on 4-top ($c1)"
  if [[ -n "${T2_ONE:-}" ]]; then
    read -r c2 b2 < <(book "$T2_ONE" "$S4" "$E4" 4 "${NAME_PREFIX}CAP_BAD4")
    expect_code 4x "$c2" && ok "Rejected 4 on 2-top" || bad "Accepted 4 on 2-top ($c2)"
  fi
  # cleanup
  RIDG=$(echo "$b1" | ${JQ_BIN} -r '.id // empty')
  [[ -n "$RIDG" ]] && read -r code tmp < <(req DELETE "$BASE/reservations/$RIDG") && expect_code 200 "$code" && ok "Cleaned 4-on-4 booking" || true
else
  bad "No 4-top or slot to test"
fi

sep "E3. party_size=1 on 2-top should succeed"
IFS=$'\t' read -r S1p E1p T1p < <(first_slot_and_table_for_party 2)
if [[ -n "${S1p:-}" && -n "${T2_ONE:-}" ]]; then
  read -r c b < <(book "$T2_ONE" "$S1p" "$E1p" 1 "${NAME_PREFIX}ONE_OK")
  expect_code 201 "$c" && ok "Booked 1 on 2-top" || bad "Failed 1 on 2-top ($c)"
  RID1p=$(echo "$b" | ${JQ_BIN} -r '.id // empty'); [[ -n "$RID1p" ]] && read -r code tmp < <(req DELETE "$BASE/reservations/$RID1p") && expect_code 200 "$code" && ok "Cleaned 1-on-2 booking" || true
else
  bad "Could not find 2-top to validate party_size=1"
fi

### F. DATE EDGE CASES #########################################################
sep "F. Date edges (past/future/invalid)"
read -r code tmp < <(req GET "$BASE/restaurants/$RID/availability?date=2020-01-01&party_size=2")
expect_code 200 "$code" && ok "Past date handled" || bad "Past date ($code)"

read -r code tmp < <(req GET "$BASE/restaurants/$RID/availability?date=2026-10-23&party_size=2")
expect_code 200 "$code" && ok "Far future date handled" || bad "Future date ($code)"

read -r code tmp < <(req GET "$BASE/restaurants/$RID/availability?party_size=2")
expect_code 4x "$code" && ok "Missing date rejected ($code)" || ok "Missing date allowed ($code) — acceptable per API"

read -r code tmp < <(req GET "$BASE/restaurants/$RID/availability?date=BADDATE&party_size=2")
expect_code 4x "$code" && ok "Invalid date rejected ($code)" || bad "Invalid date NOT rejected ($code)"

### G. INPUT VALIDATION ########################################################
sep "G. Input validation (schema & logic)"
# Missing table_id
payload=$(cat <<JSON
{
  "restaurant_id":"$RID",
  "party_size":2,
  "start":"$S1",
  "end":"$E1",
  "guest_name":"${NAME_PREFIX}NO_TABLE",
  "guest_phone":"+1555000"
}
JSON
)
read -r code tmp < <(req POST "$BASE/reservations" "$payload")
expect_code 4x "$code" && ok "Missing table_id rejected" || bad "Missing table_id accepted ($code)"

# Bad date formats
read -r code tmp < <(req POST "$BASE/reservations" '{
  "restaurant_id":"'"$RID"'",
  "party_size":2,
  "start":"10-23-2025 10:00",
  "end":"10-23-2025 11:30",
  "guest_name":"'"${NAME_PREFIX}BAD_DATE"'",
  "guest_phone":"+1555",
  "table_id":"'"$T2_ONE"'"
}')
expect_code 4x "$code" && ok "Bad date format rejected" || bad "Bad date format accepted ($code)"

# Negative / zero / non-integer party_size
for ps in -1 0 '"two"'; do
  read -r code tmp < <(req POST "$BASE/reservations" '{
    "restaurant_id":"'"$RID"'",
    "party_size":'"$ps"',
    "start":"'"$S1"'",
    "end":"'"$E1"'",
    "guest_name":"'"${NAME_PREFIX}BAD_PS_$ps"'",
    "guest_phone":"+1555",
    "table_id":"'"$T2_ONE"'"
  }')
  expect_code 4x "$code" && ok "party_size='"$ps"' rejected" || bad "party_size='$ps' accepted ($code)"
done

# end == start
read -r code tmp < <(req POST "$BASE/reservations" '{
  "restaurant_id":"'"$RID"'",
  "party_size":2,
  "start":"'"$S1"'",
  "end":"'"$S1"'",
  "guest_name":"'"${NAME_PREFIX}ZERO_DURATION"'",
  "guest_phone":"+1",
  "table_id":"'"$T2_ONE"'"
}')
expect_code 4x "$code" && ok "Zero-duration rejected" || bad "Zero-duration accepted ($code)"

# end < start
read -r code tmp < <(req POST "$BASE/reservations" '{
  "restaurant_id":"'"$RID"'",
  "party_size":2,
  "start":"'"$E1"'",
  "end":"'"$S1"'",
  "guest_name":"'"${NAME_PREFIX}NEG_DURATION"'",
  "guest_phone":"+1",
  "table_id":"'"$T2_ONE"'"
}')
expect_code 4x "$code" && ok "End < Start rejected" || bad "End < Start accepted ($code)"

# Invalid UUIDs / mismatched IDs
read -r code tmp < <(req GET "$BASE/restaurants/NOT-A-UUID")
expect_code 4x "$code" && ok "Invalid restaurant path rejected ($code)" || bad "Invalid restaurant path accepted ($code)"

read -r code tmp < <(req GET "$BASE/restaurants/00000000-0000-0000-0000-000000000000")
expect_code 4x "$code" && ok "Unknown restaurant 404/4xx ($code)" || bad "Unknown restaurant not 4xx ($code)"

read -r code tmp < <(req POST "$BASE/reservations" '{
  "restaurant_id":"'"$RID"'",
  "party_size":2,
  "start":"'"$S1"'",
  "end":"'"$E1"'",
  "guest_name":"'"${NAME_PREFIX}BAD_TID"'",
  "guest_phone":"+1",
  "table_id":"00000000-0000-0000-0000-000000000000"
}')
expect_code 4x "$code" && ok "Unknown table_id rejected" || bad "Unknown table_id accepted ($code)"

### H. ADJACENCY (end == next start) ##########################################
sep "H. Adjacency on same table (end==start should be allowed)"
# pick a base slot and compute its immediate next slot from availability list
read -r code tmp < <(req GET "$BASE/restaurants/$RID/availability?date=$TEST_DATE&party_size=2")
if expect_code 200 "$code"; then
  B_S=$(cat "$tmp" | ${JQ_BIN} -r '.slots[0].start')
  B_E=$(cat "$tmp" | ${JQ_BIN} -r '.slots[0].end')
  B_T=$(cat "$tmp" | ${JQ_BIN} -r '.slots[0].available_table_ids[0]')
  N_S=$(cat "$tmp" | ${JQ_BIN} -r '.slots[1].start')
  N_E=$(cat "$tmp" | ${JQ_BIN} -r '.slots[1].end')
  if [[ "$B_E" == "$N_S" && "$B_T" != "null" ]]; then
    read -r c1 b1 < <(book "$B_T" "$B_S" "$B_E" 2 "${NAME_PREFIX}ADJ1")
    read -r c2 b2 < <(book "$B_T" "$N_S" "$N_E" 2 "${NAME_PREFIX}ADJ2")
    if expect_code 201 "$c1" && expect_code 201 "$c2"; then
      ok "Adjacency allowed (both bookings succeeded)"
    else
      bad "Adjacency failed (codes: $c1 then $c2)"
    fi
    # cleanup both
    for bb in "$b1" "$b2"; do
      rid=$(echo "$bb" | ${JQ_BIN} -r '.id // empty')
      [[ -n "$rid" ]] && read -r code tmp < <(req DELETE "$BASE/reservations/$rid") && expect_code 200 "$code" && ok "Cleaned adjacency id=$rid" || true
    done
  else
    ok "No adjacent slot in index [0..1] (skipping)"
  fi
else
  bad "Availability fetch for adjacency ($code)"
fi

### I. CONCURRENCY (two simultaneous posts) ###################################
sep "I. Concurrency: race same table/slot (only one should succeed)"
IFS=$'\t' read -r SR ER TR < <(first_slot_and_table_for_party 2)
if [[ -n "${SR:-}" && -n "${TR:-}" ]]; then
  # fire two in parallel
  RES_A="$(mktemp)"; RES_B="$(mktemp)"
  (book "$TR" "$SR" "$ER" 2 "${NAME_PREFIX}RACEA" > "$RES_A") &
  (book "$TR" "$SR" "$ER" 2 "${NAME_PREFIX}RACEB" > "$RES_B") &
  wait

  CA=$(cut -d' ' -f1 "$RES_A"); CB=$(cut -d' ' -f1 "$RES_B")
  if { expect_code 201 "$CA" && expect_code 4x "$CB"; } || { expect_code 4x "$CA" && expect_code 201 "$CB"; }; then
    ok "Race condition handled (one success, one reject)"
  else
    bad "Race condition NOT handled (codes: $CA, $CB)"
  fi

  # cleanup whichever succeeded
  for RFILE in "$RES_A" "$RES_B"; do
    C=$(cut -d' ' -f1 "$RFILE")
    BODY=$(cut -d' ' -f2- "$RFILE")
    if expect_code 201 "$C"; then
      rid=$(echo "$BODY" | ${JQ_BIN} -r '.id // empty')
      [[ -n "$rid" ]] && read -r code tmp < <(req DELETE "$BASE/reservations/$rid") && expect_code 200 "$code" && ok "Cleaned race id=$rid" || true
    fi
  done
else
  bad "Could not get slot/table for race test"
fi

### FINAL CLEANUP ##############################################################
sep "Z. Final cleanup"
cleanup_smoke_reservations

### SUMMARY ####################################################################
sep "SUMMARY"
echo "PASSED: $pass"
echo "FAILED: $fail"
[[ $fail -eq 0 ]] && exit 0 || exit 1

===== FILE: backend/full_regression.sh =====
#!/usr/bin/env bash
set -euo pipefail

# --- config ---
BASE="${BASE:-http://127.0.0.1:8000}"
RID="${RID:-fc34a984-0b39-4f0a-afa2-5b677c61f044}"
TID="${TID:-e5c360cf-31df-4276-841e-8cd720b5942c}"
DAY="${DAY:-$(date +%F)}"
TAG="RG-$(date +%s)"

need(){ command -v "$1" >/dev/null || { echo "need $1"; exit 1; }; }
need curl; need jq

ok(){ echo "$1"; }
die(){ echo "FAIL: $1" >&2; exit 1; }

# 0) server up
curl -fsS "$BASE/health" >/dev/null || die "backend not reachable at $BASE"

# 1) CORS preflight works (for mobile)
HDRS="$(curl -s -X OPTIONS "$BASE/reservations" \
  -H "Origin: http://example.com" \
  -H "Access-Control-Request-Method: POST" \
  -D - -o /dev/null)"
echo "$HDRS" | grep -qi "^access-control-allow-origin:" || die "CORS headers missing"
ok "[ok] CORS preflight allowed"

# 2) Baseline availability contains our table at 10:00
HAS="$(curl -fsS "$BASE/restaurants/$RID/availability?date=$DAY&party_size=2" \
  | jq -r --arg D "$DAY" --arg T "$TID" \
    ".slots[] | select(.start==(\$D+\"T10:00:00\")) | (.available_table_ids|index(\$T)!=null)")"
[ "$HAS" = true ] || die "table not free at baseline"
ok "[ok] baseline ok"

# 3) Create R1, ensure overlap blocked, create back-to-back R2, auto-pick R3
R1="$(
  jq -cn --arg r "$RID" --arg d "$DAY" --arg t "$TID" --arg g "$TAG-1" \
    '{restaurant_id:$r,party_size:2,start:($d+"T10:00:00"),end:($d+"T11:30:00"),guest_name:$g,table_id:$t}' \
  | curl -fsS -X POST "$BASE/reservations" -H "Content-Type: application/json" -d @- \
  | jq -r .id
)"
[ "$R1" != null ] && [ -n "$R1" ] || die "create R1"
ok "[ok] created $R1"

code="$(
  jq -cn --arg r "$RID" --arg d "$DAY" --arg t "$TID" --arg g "$TAG-ov" \
    '{restaurant_id:$r,party_size:2,start:($d+"T10:30:00"),end:($d+"T12:00:00"),guest_name:$g,table_id:$t}' \
  | curl -s -o /dev/null -w "%{http_code}" -X POST "$BASE/reservations" -H "Content-Type: application/json" -d @-
)"
[ "$code" = 409 ] || die "expected overlap=409, got $code"
ok "[ok] overlap blocked (409)"

R2="$(
  jq -cn --arg r "$RID" --arg d "$DAY" --arg t "$TID" --arg g "$TAG-2" \
    '{restaurant_id:$r,party_size:2,start:($d+"T11:30:00"),end:($d+"T13:00:00"),guest_name:$g,table_id:$t}' \
  | curl -fsS -X POST "$BASE/reservations" -H "Content-Type: application/json" -d @- \
  | jq -r .id
)"
[ "$R2" != null ] && [ -n "$R2" ] || die "create R2"
ok "[ok] created $R2 (back-to-back)"

R3="$(
  jq -cn --arg r "$RID" --arg d "$DAY" --arg g "$TAG-3" \
    '{restaurant_id:$r,party_size:2,start:($d+"T13:00:00"),end:($d+"T14:30:00"),guest_name:$g}' \
  | curl -fsS -X POST "$BASE/reservations" -H "Content-Type: application/json" -d @- \
  | jq -r .id
)"
[ "$R3" != null ] && [ -n "$R3" ] || die "create R3"
ok "[ok] auto-selected $R3"

# 4) Validation: missing date & bad date must be 422
curl -s -o /dev/null -w "%{http_code}" "$BASE/restaurants/$RID/availability?party_size=2" | grep -qx "422" \
  || die "missing date should be 422"
curl -s -o /dev/null -w "%{http_code}" "$BASE/restaurants/$RID/availability?date=BAD&party_size=2" | grep -qx "422" \
  || die "bad date should be 422"
ok "[ok] availability validates params"

# 5) Persistence across reload (simulate autoreload)
touch "$(dirname "$0")/app/storage.py" || true
sleep 2
curl -fsS "$BASE/reservations" \
  | jq -e --arg tag "$TAG" "(map(select(.guest_name|tostring|startswith(\$tag)))|length)>=3" >/dev/null \
  || die "persistence after reload"
ok "[ok] persisted after reload"

# 6) cancel -> idempotent -> confirm flow works
curl -fsS -X POST "$BASE/reservations/$R3/cancel"  >/dev/null || die "cancel 1"
curl -fsS -X POST "$BASE/reservations/$R3/cancel"  >/dev/null || die "cancel idempotent"
curl -fsS -X POST "$BASE/reservations/$R3/confirm" >/dev/null || die "confirm"
ok "[ok] cancel/confirm flow ok"

# 7) Cleanup only our 3
for id in "$R1" "$R2" "$R3"; do
  curl -s -o /dev/null -w "delete $id -> %{http_code}\n" -X DELETE "$BASE/reservations/$id" || true
done
curl -fsS "$BASE/reservations" \
  | jq -e --arg tag "$TAG" "(map(select(.guest_name|tostring|startswith(\$tag)))|length)==0" >/dev/null \
  || die "cleanup"
ok "[done] FULL REGRESSION GREEN"

===== FILE: backend/requirements.txt =====
# Core API
fastapi>=0.110,<1
uvicorn[standard]>=0.23,<1

# Pydantic v2 + settings (your code uses this)
pydantic>=2.7,<3
pydantic-settings>=2.0,<3
python-dotenv>=1.0,<2

===== FILE: mobile/App.tsx =====
import 'react-native-gesture-handler';
import React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import HomeScreen from './src/screens/HomeScreen';
import RestaurantScreen from './src/screens/RestaurantScreen';
import BookScreen from './src/screens/BookScreen';
import SeatPicker from './src/screens/SeatPicker';
const Stack = createNativeStackNavigator();
export default function App() {
  return (
    <NavigationContainer>
      <Stack.Navigator>
        <Stack.Screen name="Home" component={HomeScreen} options={{ title: 'Baku Reserve' }} />
        <Stack.Screen name="Restaurant" component={RestaurantScreen} options={{ title: 'Details' }} />
        <Stack.Screen name="Book" component={BookScreen} options={{ title: 'Book' }} />
      <Stack.Screen name="SeatPicker" component={SeatPicker} options={{ title: 'Choose table' }} />
      </Stack.Navigator>
    </NavigationContainer>
  );
}
===== FILE: mobile/app.json =====
{
  "expo": {
    "name": "baku-reserve-mobile",
    "slug": "baku-reserve-mobile",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/icon.png",
    "userInterfaceStyle": "light",
    "newArchEnabled": true,
    "splash": {
      "image": "./assets/splash-icon.png",
      "resizeMode": "contain",
      "backgroundColor": "#ffffff"
    },
    "ios": {
      "supportsTablet": true
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      },
      "edgeToEdgeEnabled": true,
      "predictiveBackGestureEnabled": false
    },
    "web": {
      "favicon": "./assets/favicon.png"
    },
    "extra": {
      "API_URL": "http://192.168.0.148:8000"
    }
  }
}
===== FILE: mobile/assets/adaptive-icon.png =====
PNG

   IHDR         H۱   PLTE   Ns   =tRNS  0@`oP_PϠ pp`opPpO0`{V  CFIDATx	  0_ZaO0T5UTT*QQ?*GEUTTTT*QQ?*GEUTT*QQ[*QQ?*GEUTT*QQ?*GEm?*GEUTT*QQ?*GEUTT*QQ?*GEUTVTT*QQ?*GEUTT*QQ*QQ?*GEUTT*QQ?*GEm?*GEUTT*QQ?*GEUTT*QQ?*GEUTVTT*QQ?*GEUTT*QQ[*QQ?*GEUTT*QQ?*GEm?*GEUTT*QQ?*GE5FUTT*QQ?*GEUUTT*QQ?*GEUسH(@=dAi3u7 9  I$@+ϿQQ?*쏊*?*쏊*?*-?*쏊*?*쏊*?*쏊z쏊*?*쏊*?*쏊*8r.O/js)%}wO@]eyZJЯ>[Q Եc^< yj4-.pAڏir d!-p&@]k;OW8 c*S;8 vcB= : ]S`y ;QeOc=z JA%Re윇8d"c99d[Zd߸hߪ1&;mo	
`Axv9knl߆1B@x7Vy*sZ_NV( -?q$aq?$4
 _b@( ϟOiQƝ'Pr
0V?b{_S$ƍ_5 F7{_o#Egrro?dR5:d
 ŨLzM;n+~PNc	* JW OzГjΡP+ O^yT@P ۩gLw3  <[~oU V* `Գڻ0  muoC U 5kJx3  X :Z[=?  , v̬3U}  [ o7U  - v̬=U}.( ` nG!ކ'  oIն
 0޼T 
 0Eg V& @kȩ0|   H  5>< " `CS 
 q:J O/ # W s ~#US V *JVT!R 
 fvh  `GǒU0 	 =RRL % 3'?Ho  ,R}d	 < Ͼz|T;_2 )P^9!7 H_|?RՁ_  u?HT[B,jGF+zoT,LjB*uTTTVSBeHq"F 1*p)JH xGoU_$  R[|TB_(վHx   T, %  j,QJH HϏs[E   hg|:՟
TN_KX۴  B=s'e?˧j,!ԦDU'm</Ç?bggIw]eHe   TڗWJ*/'Wn㌦
V$No	Y%m7y7PB`}A  P_ӰJf匪l)>D  '[%Rs&?  *3ĶlVZ..( @W~Ϫq;_.&s&^+ju!!T*ӿhV+||t
B ƲJ6e4]b  BeǪi2)na  ~z*ܗ(`ǁ  B5?_*iiWx٢Ve[⭦>fc1Z)EJJ)caߞ|z`R+F KUStȜjJ]o' .[ (A UiﬦJƁE[   BmJfjTqS9VV'    jrNI$UΧx[A:    RV3$*(ˀa<   ۿV~LZ*Uma20r   Z*~N-v##zJ    VǯOj]    KXU꧸$WK@'A    :bRHg/ ު0   !|f(T1 Ve    VM!Mx.o0V4    iۿfdۛPrV    |&kvRNw,@تe    /fUo3j2୊    JrPUGϑjo x   )&FˀFԪB   `U;gK?20   g_ʪ)1S%; -e!  Y~79,0r%d!@P   0CwrV/S5(@    b_Ȫ	b?U}YO  `
EU! WVY 4 W:1j,   @UUDhdU(!   i0P^   z$cUjy%c~    @"Vtv<T=   KXxJS5,  yVJ߲Zj*   L> Z*KFa5ը\	X~^   V0UFԱ3V    PUW
X]/վ*5VG    t[?Joㄣ    x՜V7SzF8O   @3[~?DV)*    , 8UUD?&(ԬV    V5&T/۪y5T   0fmS_|7  _z O!_q   ٪bξ>T	V;k   P pK0O>    Vk} x8lj1    n^  V|krc     pF.mu^    y-WAg)S!8vi9]2=gF#	3DԺ|? >/~Lu4   ,QLny_ h7qL0X
 %z˔ @n-1  $JS) ]S3⤷   aÔi߮5Duwz  QjUF@K:TX iaiOú<N>[,?Ƚ2B?}N/	秖VH\8^D 0)4T̐ _> T ӈOH.QVE P`7A[qop@J[Ѥ^ k,.x/c*c={9 I*h  
KV=| ̱@ qe٠;T,H  46Wt<0_ 	:(  t&@r_ 	p<Y  +  IbQ  lM
 W_ p%E@  h  3)   @f/ Hd0 "N-9dg4RY0 UI  {&e@TVZ̃w~ |c` U7S:oW 09peQ Y	G @0w
H oV	 6@V5 y ̧,K U{J 'CJ> Uc4 8
豵  D`Ւ yV X
 1Xu߫wu1@V-@]* H3h pBL _KF`u UӠ 6RopV`- nՎCF_ 韯 *{, ̤\c
  lU~ ) N6 X ![Uz  L
L`ڳg䤉 `,uy *~H kC @ Ԫ={cK% c2S  P:ƻL /k P 	 RK  @V'   b$rc- iUvTT XIjN@ Ϫ` I=$ Z\  () U!   Th\S  ,n J{b
  gUr TENЬJN 6( ,uW,~ *7) ֖:V BjM f|Z@ X]*3D@. dU  ./2n
  cUqv V
E@M2  ԛ 7 {g69(JI#vdٻUO.,;gAQȿYUpy?	 j3;`%u 	5@mڡӻ;  #=ZJQ Dξb+fw 7kqgI>Kk[oO>>ð71 JQ!V  0eo
|4:vN U@c>.H5::@Pʯ n6X4Mѭ(: @֜̵?_Ckw y4鏵  x)gOq3ۛ}m Фb4bcƊ`O Zl  i-dگqV@"5 tۂu?Ň1ߦ:'O&5>$A<5:@Č, @T qF[C   h  j0L> 4m $ T?o}URC~'3#CAƦ d@T?}٬ϥ&3;  R<7 8B RMᏂ!T 8 L- arO!  Q h b=Ow?	٧:K]qWh2`0  .X 1dw~JR8 q! ?xz։y  +GZ@ZQ?=$.lT  r \oa0hj
D*0S?  F@L?|Ձx8s4
 d  ?=`A^~W]~Ts> c`?9T JmT]ZW r   h,ng>L 	L`$  3揢x+Vs0w m C p (ŭKEz   hcqkND˥.k8`_ `2 W`D*;6s @3 2Cwv@2   :-hkr?  S`5 ȴЌJ._4`k |P̾u 4,JO~/qDj:4'K2#9: Z@ĒAm+hh4?$$  5ae@ @c )'y}U   H^'7h h oX5yVR@ˀ= h I-_|J  5I{ 9 &P&RZ>( RF: T@oR?WE	pg m M@mGf T`  Rm?* 00J-7iU`Qǭ d=JT?Lǥ#qe -' `{L3祾'@F@ C[@; yc_. l g*df Jyf T`p59 _p Ne 6_2^WX0I @# 8輅2 	/\:^*E { 8 rAk,N?e_TDPNR@H ?0K$Q . ~Z>e =S&@ Ћ M[Y!erō3BH" 
nHO  ,*KMT_As	@ P1RKv!KHRHI @Ov T`+ુ,c  T)(%ʥB	X-nrL"r 43T6;=oRR'(e@ C S ; `媋"&_N	 
md* @*Qɶ'\9 @֞	5Y|U5
z29 owY T 	8^*XN 8Cg6}@Igӗa2T	:;  ӗ  R$ *V (@Tr,-@6M uǠ@ؿ j! +(T @~}T`0|U8Ke Y@K 8 %dDW -\5 TDxTP7 oEKϪV @%c 70@O_! -~P9 fCJj& П#Rusi  Ԃ k ^*Ref-X9 m qo T Ԃ=}w T h?I5  P
'P7 =S실2g JW ; lL+  RgLjA 0 Pa@m^*1\TjbZWv TT0sCՂU,pP}P5 ":Ek }aGP5 f.PJk֮:P.zr
  =o2@Ƽ  R 0  h+<J2:  P+'[% ]@oIaxT(6@A   3Rq#bgX e9  5Av T zZk@*{l,I8 |M%gUV  Th@  1{ଊ|JE7GR*  @@ٿ3 X*T {v  Txxd0 Rv   /H 
J@Mw  ;OR RKk  +	< J  5 Ԛ6g/$$4@k?eS1 4IԲc@ ̀DdW	 [;P MH^o ޜY@  	{$\ g;P- ^y'@*pެq h,%$8   RxI M
 v  :p?S  /- R?N` @dqc3B/VAw98  v 'D! k7!  =RڂR& `,Rٵq, 8 #|PaVg
B Ƹ+bb /W~ r@iu{ p |ɷC #ԅ x\D>> &W@o
 @j  2+x B T}  +< ;E { >`Ģw͹i  8  p \*Pyh o  ,0  G;  > K  #+*N XL ` U{  +:_u\;    p 8    p8   @÷SU_ p p M ۀs×T }8   @= =}8 N}S 8br x[ط/=3w=5~} 8 ^~,_# f [͵ x_?৿  b?#(   bM.{^i4)(e Y@ZuB[x DD d` $ZCj]29v> LJ
H8   lBN? 5U>* xH$   ~W
xg`KzĬ pnfM6fgT*&v *|^Q@|9R 4`rqUV1] 4#QUj  7i]nr] xVwY`*	   ;_o 'MoL:-~/: *w&̒\? xR`
 H @ C  5mxW  I   rZAch^*w,  x608f`j MH ' N~
2	qT>T28"
DT
4Yo |.pX' @D{ 8 $Xc,9Z l2RGX5  SOdKjhGFjAYӪ 80/p RM!=  b+hZ ZԾ*v p t̧T*| HjG@)  6 oQ0R%- /P?Ӫ H{l@9p 
Je)= =vT` zF3 { @{g(%[FjAp  x*2OH smɽ{ 8 }@\eJjAp: $ "R9  (U H-cj  EY ` gU p P/#d8RU R* DHjA.1l H
g  T  ( p @= $~LԂ   n/,9SK-+
 C #RM { 8 :؝
 + 8=}&@ p 
u ,Q  :@L  5|' ]A  J: DNjAp-@+;Nj] |7R`h C!@Pj/t+` @^ -/(   %oe$5 \ RUL~ 8 >0;/U= RR,' sWLP~gsY&m`-DP  8@ٟӅJ-CK [LjP- 8 ڙZP R_5j \=*9 ]奞)E	 8 (e|m k2P%QQ}i_ʕҏ6 F[6i  m>R9 @jmZ  z,f(cn 3 HD{ 8 MAdaSA8m'UT 6T	`  (LK-Pj.V Qn  uLLV #`Oy8SUm3 p H G5vh"5`YӤ  ?:V`5FjK̿j  !w T~\
lZ R@  ^8Upt<x^ $oTG
{#& *V)@V* ME   |ۿyT~7V@O R}\`9@T?>T0Ė}W "׺ ?$E% 8 :,3GL /n6 hlB/T O t؛J|[hh8 fe(H9^X7h TJvOY5 `d {LO5 @JAg)Ư XO  ~oޜH	lF`R3uLPK󄓔Mm Pj#Pv! Aɶ9 8 @(T F@ H]OGؽW% aAU1 ὖSY;sM ojpH	o- K=pǥgMh  ,~ 
,ӿ p/AI p ,\O!R 2.
t[C5,[Z%dme<PjAb "k2
@2`H*Ty !5 @Ru & \ ?+4~0p?ӣh `$  x
 Ԃvw [Nc9Tj? ܱ
wX_UsӍ  X 4)&:Əpax: 'q@gm$C \*yȯtߟRJ,  Q	 T(0 1_5Gcjq|F]>) 8 d؝`\4F\*(a4r5 2
   JIʥ~C2 <KGن H:icyyssfi.9@ a 8 4HdP1ooV^j6󱋖  @_ 8k4 Riجcpӟw 4 MqO0R c&-BXŮ뷟?? | ǾS p c$C:w_F~ӟw 4 xU  CcP 96 m煆 59l`ǴYjt;2 HyЃe@cWeuH  n|+>6V8΅,.u tB1kx["ژU  Z`fhk"e= 2G}r~Xt#0e v (_>nVot),
~ܧ d`: @KRΧ&zQ 15 4 P/X Ռݗ?;J 
 7phn!ޯv/9ymbh̹pi  Ϗ}oKc'z	
];V18 ut h`ʦ[JV 'z\A;[ ڍ`=s18 ,&9@ꀃBꁭ jfvU_ eM .()!@|8 .*5d@WU x]qp \Zꀵ^w ^I e# @  U{50Y2$paqk 8 wD cpIL  P!IrR@ D@'ct \J tYhG@4TQ|ܔʸP_{L;уx9Y֒	?T[ B0,jAO p Po 	jMO p PomI OX	 n ~jh|'**   4TF N B @ k{# /[+ x[w.* *@; VFƟ.. *@;[w	pQǡ󽿯IKꋱO ZIߪ vIVAPՋK<u!" :Tt3% 6 @C{;n 7X x1 # @`* xX: p P>llIs|n ު Ph?~7 ^lY6 @Zc7R UQ Y {IU"* i1
WA )D I
 <
?Ԭ K5` Jna>? C lY?dmBUA H%TC: E# c3Z Nnԉ- \?vBQO| yt ۤު PR+
- @gNU 
 i9D. \qEbX `oF ?xlb  XrG  %mF   ꀷ4 @g'%x" $m  tfY- 
 ի 	`iN! hNZCcA  BI) @g)Xe Dު || cAP	  jթ}^ 4YI @h<|  |NxV;N ЃP=H Q@'<A@ ֹ]9OS]]҇tq8$ f\	KЋt
$s]]ak $o:s%4՗vM (	8ωC:6( @37_+Ž Pǀ	VǏuXF5Xe .4p- N[`vWiYR-  k?ZDCu:hL  $˳ m! Pju wX`Z *j/B /  #pNP  7QWy`+Q-t	nni9jnD#8PI [b1$F7rk6 ILm 7F ^!9jp !#Gǃ   N5TĨ JbTaܨZ >F91Տ.QO[kH߾ѣ>, yA@  {Q#W ѣ6   }QCIB< 8>U'   X?jGW? 8Ǐ*\  0,b;*nB 	@e"K !	4G 5EԎz@Q/C 灨IU9ꡱ! PN<   SDՏ Z"j= @'DՆz(F[7IJC /D%Q-^RDe/ 
Divԇk6+ ۘ?ATB =*&jpԇ) Q&[ &xPi{Q+G! 
(RE%R_!U~ @ ,vK!j|s/   zG,j
Q_zoEm>e@  JS\}w*]Ԇ  7@~JVotQ;@ o}H?$.ӷ|	[U`)JW]cqQ NUPjCL2*#?`*H3PkjUt6eT_FjVmSQ6mT?`v 	(
VUk(JGB 4`Q(ebɭx:j|!  D^2[YI֟Gd! IUyzbV*  HU^%L_PV円?qf _Gn	9*?sZ5 4g!  Ee
`j1o6+̀0  7@Ҩ UjU`:; \? pSEg29u9~? TQՅqZNժ
CôjU   n '&0elV,l lԎ`¨FUd*IVfEEՄ @ @N5~*YDRuvf P*3 FUGcn/[ZRgEevLz P*7@3u[<+VY>Ӫ@ ɣZ]<J)!OT+JiEdvN J>*w@BxI@'_tqQ9@8DaVӂRcP3EUfwjP-jЭԯl8.`V!Yp3̼?s%fu
P-y54Լ *[Dω~U˙sε} @1EDUYc y_C (WQ5\K?|fu 9Vv[q] %fXˀwZ]φ^qg'a7 Y? ږv3Ν?]ORU`)X_]ԯ݂A (ۀ TQfQ  1H˯ha  Jb|Q!_!hufPjG_ 8TmhuLDE Pjpixd@s(ޢŀRo*ۀR$'*ۀwZ}Y?R!h~dIkyhh6ԃՅR;	ރr{rAQ@^0 gsZl1o/Ъ*o~7,J{h-WQ՗
@+^ j{ %j"hg~YZQ
2{".GhUD:{oW6  @7? wԋkO <E?Vc-z  b
@l? * _/W>  qW?zj  \j?ng  @xVOE  OL!jK   v(cZ @ 
(iU<og  pzڟ? E)[UC `?\(NUj:L!٪C P UZ t-J3 x:G/
V?_ <׎^ebxL APj^>  _4R*  JQr]7  \VҪeOn1  P*^a  '8UR[*" 8;VUS1  ?nZLVN .teܭ}~i ՞n:djVf݈,V t3eQWt3peT^*~) O lV]Qɶ pe~WcbWbDƿ}1  ?hOTVҾ>Jgyl -,|Z)%_o(:š|z`b  e ptq`\> pA9~ O˺pGp1  ǟN1>rُ 8QY{ğI3*vD Uv~6@ ?Zoퟏ;--`Q! D;v=`\{c  X轻khuQ! DRns.Zɿg 0DCw׼'UQeTTUGEQQeTTUGEQQeTTUGEmeTTUGEQQeTTUGEQQeTTUGEQQ+UGEQQeTTUGEQQeTTu 2II$@ u*?*쏊*?*j*?*쏊*?*쏊*?*쏊?*쏊*?*쏊*?*쏊*?*쏊*?*쏊*?*쏊*쏊*?*쏊*?*쏊*?*j+?*쏊*?*쏊*?*쏊?*쏊*?*쏊*?*쏊*?*쏊*?*쏊*?*쏊*쏊*?*쏊*?*쏊*?*j1?*쏊*?*쏊*?*쏚?*zۣ   a[A	TT*QQ?*GEUUTT*QQ?*GEUTTTT*QQ?*GEUTTTT*QQ?*GEUUTT*QQ?*GEU~m+pf6    IENDB`
===== FILE: mobile/assets/favicon.png =====
PNG

   IHDR   0   0    IDATXõklUm)A[Jy
eiA
@`	( hLR4"E/B(J@0H A@IETVB(ji33K-̗{=HvHn{HJ ʨ6x`JRڞ7'@j%pFȁ1ȍ w4J1d\mB(20}$%H=<Kjepj#vZؗxsw7 "I+8I=B! #LH +8	JP$  yYص5yئJx4IfUvޯZ%~a>6ӳpIIҚ8+Iů5L2ղ1?Bq_@ `: iiZN啔XaaưUa+w3Ձ(z|\R@ΩHhAc8lMqnYGKjfBl$emIB$(SGM3H(Y\;o8;$L):s{o?^~Vi׵}h4b93)j Xͺ*jգ%ez-^p(6[*MМDB%+th- O"Df70, )h.(ǁB:,LK #d+%	Q=B: P.3P.Ya {+3fq3 ŎZH` f͎126Yz%@(o9msk Y;z<|(YBG}:6 d+|^5?Rr=!Yc/-5Hfڊa'jګr'/${ǖS}6FDN*Z;KS=Zb9v,u7T^&|tϋf.H;w,bqMDy`֩T3\3!Û#m!ƭ6'&=ĶKvp'涓gg9eqC;s'ƊÛ#12AJ%iTbnMa\qss;*
m41GIq>nY/)aO җYTX*c h~]GuOq<D9fyW=p	.Eu%c$WyʴѼM [YHC	AJPflv,a:єAc̖!F$j@!m=umN22jg9Ӄ1Gr+)d$mnQ-숼{/ki-?=j|o]v ޗ\mq}J2Z;EzB]]< #CG$!oQ_,I9+u/I&N    IENDB`
===== FILE: mobile/assets/icon.png =====
PNG

   IHDR         H۱   {PLTE  VIDATx@I%͎Õ@}+(O|UGEQQeTTUGEQQeTTUGEQQeT[eTTUGEQQeTTUGEQQeTTUGEQQQQeTTUGEQQeTTUGEQQeTTUG%UGEQQeTTUGEQQeTTUGEQQe[ReTTUGEQQeTTUGEQQeTTUG!UGEQQeTTUGEQQeTTUGE!Ęr*>oկ-˒s3m}1eK%XgKxH3?+p m}<3+wl1/{/גg8C֙[8 OG(Ɗ"QʟHBMg7OwgrX'89r>'Cc   W&/	} XW*
?OB)`" 
y߳?Z  Oڶ
i @/!*^a obҟ7MV[*@nﻰ @+ۄB߯+G*)uW Bӝ3HCvF+B*Em\|s%0 PL/o}Ԩ)k @]0DUbx1 POBD*i``lz @+Ò{v$F g- @;o{%I! 
 q5VSQ`l4 p HrSmv>  Z lTs <gMJ  / `?x@j~  p ? 
  7o3쳦   @澐U/, P <yDl4 Pw '
\V  gLt鳺:7 @ ̚Uvu2~Ʃ *+ 8#+9   7W,cj*
>ܐ~: Ԃ!`,:[wFa
,:;d׃0VZ*^cUVTrYWo*  |W'SDƪPa?(
 u1T$  `Nd"  ڗ'}7k
 ȋ_ jMs	p RZD \ Dk\JX {?dUWj:L;V* P~,(i4Z/UUJ5;   ;^T `'  0uV
 1L _,U_0 S) R2* _
 *
 TK' `G4
 |[* P@* pw鮰 H- U ச|9 S~+  P\?  AjMU `YP?  LV    MjQp Xg^ Rڟ * pK]! LU dI #Qp W.z tx8
 ,3IRQU `Y/8C[ 0TuW Z HU}RuwS3 PHURm7{  `TU'h\ MI#U5Koq W,RUT
    (L^!UK @?jRM/* LH1   H:ԉ; @FFpHѤ:u] ,CJ  j1uRuL6? @Ry攮 :TvvBW vKRul"@U nG/3
 ЅK~U ?HY:~pW n?F<R   ϧZB*evptW A#Ugj:nptW ,=!U:L`* # R^; RuNv0
 !UgJ* `=Ruf\OU }RH٥rۀù
 L]#Umi М燏KB}돃uhQ'GȿyהǱ{y	Ͽֿ`kq|Oۧ<H+ pzޟ_k֗w"t8*f$  r.az~%ֈ pp@~iI n},L?> /gl0G:[Sk]*o, _; ><\> /Ÿ  \؛UߑzWko  = 6݃[ a4
  8u/VI;WNW n8   ?kJ8LyknZfX  >0W+ ~յ9B_   ˭ w1Q}/TRKk\no3֨*m]    :;RL-6.k]A? j@fBn?nDT{2P] ' T K @/H~MTI%mܰި  * %_= P^}ԨV   .H ݐCjmdU- [* ݄%}Una /U I _-8=IMLFU ~-I ʗ8.2EfnFygk^
'v  T ވa^5gZ> ÀJ W  rݼЎRC`_3% <J _1Ҥ2)s6aV@V,3DJ G4 H7/1F  9&uZech{ FT 2[RO!kw hJ
 8>b/ſsZKOp L(u?9-D*?e	 H* I[	 " `INAKL* 2 L/bg]?R7FMՅ!   Rgl}ObnWf(#@"  e/Rj9ɑd"e] eR祊
FZ* _rPdRTM* _TMjKH ɿ0$I/U~ 10%EIݥ5/UBU `b/Ij9!GQRwR@⥊&R &u*ߑLWKCQ* _Tʳ  VT^* _Tra (REK 1YR FԏB} @b/G˭Wr?pTU _ " @ #)\? IT~	u _( #Iۻ
 ؏C9 nG|~ @(m xb%s @Rw  FHBU `_P՝?t +\竾[{A	ƮFicWW-CN? 4w @f:r? N7Mc.m* D.uE (#`"9 `6O0>[H  < :?:Y
gqWi `՚FļZZU ic  kKEKO
 0.DNZQze]zYUT>lǎ7 FRQ BڮËlE
 l'հu\u} TKa  lt5`zm7Dv\ũJy aIӃʢ~|;U5IJarV9Y_2`+NU
+eDq__T "!Qo5ł;w>N6nZqT " XI* HvH M@ͯ,e_ w6@QAy忧SU"wXEq Jo;+ ] TؐFwQ<_Q2} H,WZ+A`y]@4r' #u$5- h \w] fAhh?5Tɳ @T掦@MA/N I>^6?} J C/; ػZf'5	@a#*  R{;I}_W NC5sJ @TPy{Up}e @T.RXimvN&g６ ZFHp94e$$UQ-?srj 5T߲dxE*pUSԮ[u޾aHЭ| go4|ePMg$Q@|'{Fw
e E^kxxV8E**P2 z	xǷ_!Tc*Pϧq?j `jUANYu C50}@ˀbG]}@]?(D`%~@]?j~	?@:ux	0j]ɟ8<Qe{F@]|@Pi^Ճ=TK5jG=;w8UFeݨ7%
Ԩ5&Vmpjz\jTׁtW1BjrQ_M _P!>r1d/_`>2W3@oF0>yC5W*PcH^x	xCu5
T E-J7TÃD˂5TqU%<&9XE`.jb\ચQKxDk	izknT +jbxkÂjG=[Q?vL U3@q16 L 3T6TN|`I?Pu;NFTI?u.jU] :\U3AyEes\j UfWASzAu/^gc`U-&]Q7+1TWcxZC՟CMV:ZpU{zC
W:*zC,>O<jU6>J V>Umj'XlVN) z U,8P{]AP ״qUY6ԡUM-pU˨E߃PDa7@㪶Q.d߹Ϻ UmzPuXUjHL."ppLkUjQAW@\7&T7\ : UA`j=:[ &W;ñ3R (3uuA- Uÿ=bf3_ uP)4y' \0vBдc"0URh,뮷U^Jh*%&E .
c# Z xX*PgRh`_Wzo  ?I{@ @ ZmpT	 O<UOcC%qcѿW	p4Shn q4De
Cm p4TQ UW:I`@׌^p܌f 1F/5 
ԝ4:8?j@xQ)E~r [P)t!0:*%@9? *P	;jT /L@}r7Q{m pl~{`-r5 
$ GǪK ǳAE *P+?]n:EKe+A]C- q.)鏊s7oTH|3JT	T$U#Q%T	HՐZ*~(WJ>H~]JPu؁'%	7;?8T TSA J+v%M	~o7_ؿ8<ѣWZRkI ||L8T~oO"F8Ґ ,q>D~¸Ц:Q9Nv )ގ=~Q
Z|/j3@) s?;ɉ*y@ul9mw0;
	rnh<GsQ]
YYa	M ,\	(H 0<Su-t_c鄙*9(X d݇ h* %n(8 p=QŉM!UibDؾ w *S!UiZnZ4>R`1Zjz6fúb	[oNXR6  vVM㶺Ikٸx-i[ 0'SUibJV	@?lTir(ۦ JSDUڀД7R^Zt4\v K jwom@K l	ȷܯ_wIk>	7?VFYwX@/BM˟k
J MsC  T9MӨ/p
U u6, jY[P}) ځ&F}U
 ~|R @Q88|Q
 J?os@Kc
J :Q z) TC
TRhg{>?4R (oZCma) 66
 HuKǥTu
 a 
 2`n`Ua	Qݎ@+Rs-7  u]o hDq7:. TP0ҿ W @4:.h 80 @PR@v LŢN{  H*R@ZXU0>Kw r-}'-:pԷ/r{ -ھKföUP(,:w RT
FK>/,j _RUQ,Q}	0Xw jƌm$ {<yTEIQX R-+}T6/ǨDO}R VV>'`ΡܶB:`gaf<^O BQ0f/_KT?<Sw JK J"tX'nEąT! zk}Ts~OjbtR} Q5hTJ6ϸLL8[٭g)Q`RgV!*gfonoN[L3+ϣs5THQyV*gL	Pk@Q I3%sXQU^3Gm@:wy!(Rs5zM 04R	՟:tyRA<6
^6t jÀKj&ե~DӿpJڀa@?":DMu #sg ۀpH$:4
ZJA`<pRXW	8PA+Pw|Ӗ*hS?73 @:H>)@Uq1
2{D=<Tӏ:c|\xT?
 PA	xR >T?6Iћ/RI }TMqgh ~CNQ$QZJuC >noTb4(''Ud-,GōY&'*8 UqP}; 0ի &U |TQNXTy?- )IZQT.{ ZrOa8')zjG;$Q]/yU/(	< uJp]RGնo8xQ0	Z YJ5)U%k[c#Уz`P3)  U |T(@	G % & o  AD`v)  UxGՖn{  jqGUl ZqQ<  &&(Q Z0C` f(՝9 U8  {GUCn = U :I em Q& ERXQ`/	 vCGej Yj̽%ɿ O8^
s+D%հ"_J 7om
gUPW/wyqR-ZU7 |pmP}R_@_TG1*cv <Q94ǀ2i5ږ& ) j*c@@ٸhU{  +z!<YH  Y`QA @:q9T'4|T-@ G6 ֬XT8Qf/͡62<{T&@-^ FITm t J>2T$TIT  Է?	HPw=Iu7ET	lu]mfr#YO2_x_O5ծ%K  *{TۧyI"CRUq 4JTnR30R%9@R@:  ` W˥ؤ.	^7WUG @=Y*'/~V]sP8 #/U{|RI }P5 =6TD/6$CsP1"   jRI 7) ^R!yإbz˰+PEa 
Ku݅R5cI꤇ h p K U*e** hR ImRWl[z  vA n&^R;U*? [RpE3_X\KUe @= T/NƫT*F/ Th ~lRh *V  @bC ʟ:߶"͸D  j߹mwT~]vDTb rvIvTG`\KqxCKŭ#ەN=T	~7~T0  @"퀳A?R;_o3nhĎ ՞H~mԱ ArC ՞4I^mKUs	 8^dN"\7IG':y|  l$uDgiʓN }=T3ЬR#aTv;
(S1 7(R!lM.Gx!좰 R{ݬK῏*    K7_ЉTv_ԥ  m)7 
K* [K +:(Ri %*R]2m<@: >qC T~-YY_ ŕ p\R?3C޶Tx	o(Re ʿ}ԥzq쟵m[;;\ž5E ,~ةT|7H%6 ]?D+S| H&cޤs^ Kެ اRF r~R- ` D*&u@}]m>I, *.wSIn*} c|Z]s6܉ =6	ꮒR.Ru bj:0i~)E%uGq
80|2Z О Þ*ڭd *}bUI~;&: :[- BT&o-N+;4Xp#M
? tWllGng6 ǤE|N٠+l+7()jx?	@]RCFEQ}@ SvTM|#I6Z(46/5e@jM l3 |'J% ON}@ڹ5oUjFTu?ֹ|S rlz<R p :5m_jnrרzO@J0vfKp pY[Ao)"bC򭀩;:\;8 	˨;? m~j5 3rI6-Us {c 2|WI6O*f0Iն2 3~('I9 '{S-oPiL/ 8?|/ yKi?9eVu9ݥ6)0oZ w՘L@eZu ).Q p <"5  L-5v@V= O~ Е{W1| 	| e   ,7| ъee!><T6 {dYښco>g  P˪ 3
Zw.vʟ	oR|ekY3y
  GZ2 Z P` @ СR ]^ * U~K7Bg[fVR lk@ P JkW 
 F * d7'%7Z (  Jj P ( Գ,  @ PR *K2 W>@T ]UVj* wUI- `o.  ~ l5? Pj"PM*  
 sk*>j,x}Vk,i,x+.I!)_?lRwV\y{$ &N+0  z 0It^	<ʇJW@p/gIZ `L'> 9]BP%> + CeZk z=ptŀ?:W  > BjU0n5> R!$;, %ZWd `z,VӧhS @W Go1f(`'@W|T(ˍߝP	U   T	_U[k*5Z6>qۤLT"U< ":bZ퉆oP`=e`B | e"h&9ش hR%uq?t2  z>T|/P:lS-n HVƬj7p@2+ zVV긁[N3@k 突-UK+r  oT*	RMM;8 $ Jo4_+bWWƖDjXM=hb=~IVUk&urm~ui$@ U*;\Q@B;tW  ?W>f7  	2wWRն0=_X]%+-5`KԄE-  -h|m{9ϕh|#*=¢j/*J;7讒/Z J{t\m6X J REFnMM+ktW}HK/WU`+ =d"N]MVP]E.TzYmVtڸ7Ҝ@bc;"\7 =Ԏ=T.v'PE<O Y>]ƟW&鮒D̖J7Tk7I`@ۨ&{=-|XFh2閟ԥ'~=ʙ:ktjᾱ"M 3@gK庀6/Tۆ?Lsl`X pF R}qwM<p9kv"RC'([Х:{ n2H5T*6d 5/j} | S=Ƨy| ;R)]&u΀}
]KE*9جRĺI}3|Lp@JN `"t+cvtmwU! 6Nh[ه֤ #>1ʿ\:U > 4<S*?RF`Ԯ$~=g+cތD*ިTZ_	 4`GK   |*r-U @CZ*- ؼR:IY/3hoM .- " n׸IK, $T|fV 8! z*U"'\f @ oRd9D @C[TR o*5h҇z hp K ׻ LR" _ , !H(U\ X6R	{_`RvC8U+# ; R*_)we ,j `>"\dD\f  K\ > >"5$-ׇWf @C%8R]) ԑC]I `
 ~F󰭽2l?񶍥K 8Id9PI d htK5pkI]x~BޑO[=イ2C`R9@gBt0޶#ni" p  #jum5 "[U `Kufd
{  c] 4N;-vDׄʲ Jv0\VjM9u_Ӛ<_x=@:8W8X:lt(gvb t7  <*izD b	H{cI @Mm &bo]@ ՟^w 58zPp>,P龪% :AMZo1cwJ;ꫪ,mQp#DD3@T퍛koz2&]=*QY~_^7vd m`ksQՇbcjANjc QQ]K'V(GW~؍4C~/2>@Ԫw*Oxm F}j7#6(?gUu
 l P}|Q!bkU
?<UEX 6 b&U5 
TTn|czM8EyT5$j5 H*`U݋ ap=ߔ&{ XUsW>j'@1CTH+],H.]_ jжAD,QvO z= zv8 U; } { XUm^ (QG%?%MJ  @?Nw  G >R=|Ԭ_$y՟>(UJuzX ͣJ@J 8 @;Y- j"髪
0F zT0MF >R]M!P(߾`Q}ԽRԾ R񒴯1 TWq$jMjgl 	U5?cT]  T>)W 	&EE} }IT* @Q}{T cBvTkjۯ|TG僮BQ?!~T7zE>G͹5_TG
 Pt` s{T0TWJ	W*գ_U [3xpo_鿔:Q.U m_GߙƤ
V w|ܯ1Pԇ@+ǀ^{PNo _տ~GcґJǀ^KPS"EjITQ`~UkϖJ ouiz JuI.},꯶TqN`ܻe{6c+mzK}H5#RP{63%Yԩ^{ +1az.T?2$aɢ	_Z|`cW< MR]ڬ̵ϻG\T6, MRf%՝6yT 5 .!FˀJuKB.K[ 䊐4%A1 Ħ[	= ^mwmQP} I`T;҅ԥo L
w 	= jeʩmծsO^csP%}s7A zGጚ@A9E/6*WvUQ\KɴУJ >Qu޲mQ  C: ş @f}[Q%EJu @0S̷̨jP% *+L|.)eoYϰW@=t ש\xxCYU@ (P >5O%@P@I3E	y̨d{p*/  hK Jر˫ ިY> ?#T-vgKPce@^ ; @̎ԑY~^&=?&TMT2@nw^@FoAkK [x?ԵtI@Jv kğ |۽rxP[/*/ )hXSc*sQTV_ԵT# Wԇ1oL@	cN#n͈?9FXq?/fTXyU\q- T`Q,p*&T=nWꚗn IQ=
 p*(T=sZ95<OӇ;jeQ FcQ}=/@k>jW-^u[=u*׃/ /T{-u|
ϼ=}x ut~	o ?3A@XV35!ĘRٖںMk y5K *
0[qO~	s e<P;@QPԍ^Rܚh;@?/c@SG(ՀV"UT z#@x(pjy[-|,_ǀnhEﭥ%4Qܾc@S\Tl͵x >&=*382Lf}g?5Z?*1=;Ь 0&pC2o٫TWlg"(*5IImt
΅dg*J8zz+
@Ӊ9:}'ꔞDO FG~&5<aooe^o['<) atTm7ȫE/ QEFs~%//`Y;`68rӵʒj^ _MIK3P9g Pu87_?"W	-xvn:B^\%T(zxPAxJ~MnG/$8J\ Ʊ \(R\%T 2ryu5E<UBHerob\%Ͼ6^A7?ZVJw6 6 
6rP)+\
@\2C=	
@ف<sO*B UkM\%_:l2G NuU 8k*v \ ѿ-gUB=T {(W	վw㿲W  鿛*DBb\[l'W	(:~(W	u; $T  w* ܂ ?|j-\%7?Y ޚ\%TkU # K9CBpqjvmE5OY*gj,prP@Fp6\%Tlk?n`W*X}PgN#orP:CZ<\cIP a4_roT |&;*Ϩ8 y 2o*Ǩ	!W G`擫ܢbG8P`~V+
xgD1MrOT<t_3QWrGT\ <3gG\5 UhQUPwI _LDq*o	gD^G|b$ ),0Ku?٣U,UUCLE],նHQD .,Q\ Pڵ!j&Wy@WW*݊jB*nVoVTqG=pE]ޭ 
R W'.jz#Z[ׁ\5$*ڋV/Fen6l\52*k\TM O	j\5.*5qQxJqKo j TmԦ	T{7\5*6	ȥo j TYɨ݈zqK5Tx\5jBu0Ko'U٨IOebj$jTګ&gR5#U#P>C#Kլj T[]j|~W&z5"WjkKC@k*ts?U5Z UL	ʾUyw9aUٷjsV{UHʍUV/X[]ïw (DpdU=Uש +Dꑭ`BT Kêz\FG34P bu5[ 6P	@ X:akXuwƉMLQV `uC&`IQHxUE@kXM 67V0bu 	hUs{Y>Sm2@Q*>j8QN׉* x&g6 [ouZ&@zkXuo!d0D	 =V{ױ؅`$1Rq}8I*@ )E5] JCC ض?$%3-iEYmֲڱ[u'SM`;{}1iE`jםձojQ  0g5/տ<Xp/P:fʥ! Yr?kAà ֬fux`1۳^Tn)iЬgŽQuZ5
Ww
/tjE5_ bVw ˏu- Vq6TDӇ1tɥ з:yp1jTz@*NOz j9:6EGz{M{ =(ب9 x LQ7@j5'SH#%;Υ! 4A^+/YR?(G oIŪŧ%<`_Sc(U?79rV~2vXpi 	~mUTnm
`՟Y2r>V 4[ 6
*̝YD(.X\dtK@]ŗoá8$# jZmGɨPP	*Pd\RWڻE@@?Z*u{W~Ev& [}
|eE (W,,9-PViGM&_+PR??`MսkI"9-P¿}EX Uz8pcC ;r!Kk*@^a4K% ijQum j	MJ_bk!F ՋXqIQ ps58/|  F5z7E{Uo~^bJ ؁ DPO v]Yg)3$ V/Ƈ, գԵx/ lP~WQ=	`  6˻wS% `$ -Z%NO -LY! G"^O OtEcV=  O?' њ)&?TmY ^v}@@ cV[W-XqJ % Xv@3	Z% {G6a=_"! oUÍh`"Ym0$ oo 0O ڎ Z@!S XڍbЎjr_E?4
O G 
-v_?Z5XӁ P$@ VgLF :PA/r,ѓ
[ME7XQg F̊ߢ_[ 7?PT',͂?n @zj  F:Eeͨ[ Z%o#-+^J-ۇj4jTA:A1]$@^vTFE?* IQ	(P pp~s_O bQ	O`p&T>Tk;Ou ^0NQO`vUlP z FUd hU`Bl)	@RV8*C=섨6ᡊL:ß[ u
+] t`WHIckeu@#'"9]? o%VTUy']Q,e..&Ί@b 
y6"f
&q[ AyIƽ-E4[ Nφ; 3@a~m_iYP p<=*ߗoѝUB$- vz d8Tt>O/%	P [m<xFxWJ<cŏ(_.]`F hB#/c ⿄:|o!Mwb@͇}+<^M9fJ!42:tBJ k
`3Q pAGb֕Rs^62 lUT|)p*)/R$c_[FȁUǂwl[ 4WE	S\Kܱn\%jy4o&`~qUS`gZv-tNa[zzK#5*&DX#)igj<f \?u OTDz9řˏmͯ2 b4b0c\p\h6˭@3ğ/D JO8)#56D֌΁הΆ.lWU}F3YlHEqd6]ovyvw?Fb
@^[)2gC)DuT b/<K3>94IU  M`{f˼Ͽye9'V_qLRUۯ֞*V"'XE熪*ʂhI
 %oL |k@UZMX8* ǽlhUV'B0
 kxZէUK˩ w3?kvB
 yUYQ6* P?3ѪK rßVbUEG @UX L}UX]:w* _U[:K ׀`hUVנ~ (UZ%* 0C jԪR hUV]ԁ =^eCڳ^\ש }(VfGߩ@jg)l @GժCDZTZ(:D BPCoU_;! zZuu.T! OV?I d0VC?CU״bO `-U}%* (=V], մ*O.d5? ਮG P7[R ;EU  'U 2P jQg2 P?I  cU? Q]gQG P&R  jgQGR Ӻ_ ewk UX-?R /` @VKϖTe ST  [-6K"U p*@G  8j/a"U p*@ ηZlI   εZt
 J DD m gu
 G  8jro!U p>yU |߸ ޤzU .[R=EjCUVR?*?'U P 4)՟T@UlI%U P!FCG(J u}+>+bI ԋ Dz`I T8XR}?zCUPW&nH5 'j="Ա IH PǍ3;Lz_ }HQRRuJEM
!ծ PeۘHUSG.B2TV?'V Vo= g \ 0Ͻ?ʆ   `PNT Z ڧ;	.M6{-t_| t>dIurA{ <4(4 r:Q~FΒVP\gKs'X  ^
l!'ʈe{.ùoLq}7ԟ/MUv) 8i3Ib=TUFl (ݸvܩZ7z%ѳ/ P [2MAhSꗼ (lŋc*l׶u? /A+OV (Nr^զ͍w_ @!W?%W0DY  se޾ @#paxiRU[N%! Ç^\^#8izUXz.WS '%r5).&x'bU:o, /i&)Ōs~OD:C0Ğn萌, 4ur
pJzQ rZGl, -h@-p i O_r7Y  @W<X@U5'>הx*:|}g&.S&ju *_Y)Ecwb-S=*m"oA\ ?1ƘWםy UTQEUTQEUTQEUTQE?*?*?*? TQGU TQG  AXoqfUTT*QQ?*GEGEUTT*QQ?*GEU&UTT*QQ?*GEUUTT*QQ?*GEGEUTT*QQ?*GEFX    IENDB`
===== FILE: mobile/assets/splash-icon.png =====
PNG

   IHDR         H۱   PLTE   Ns   =tRNS  0@`oP_PϠ pp`opPpO0`{V  CFIDATx	  0_ZaO0T5UTT*QQ?*GEUTTTT*QQ?*GEUTT*QQ[*QQ?*GEUTT*QQ?*GEm?*GEUTT*QQ?*GEUTT*QQ?*GEUTVTT*QQ?*GEUTT*QQ*QQ?*GEUTT*QQ?*GEm?*GEUTT*QQ?*GEUTT*QQ?*GEUTVTT*QQ?*GEUTT*QQ[*QQ?*GEUTT*QQ?*GEm?*GEUTT*QQ?*GE5FUTT*QQ?*GEUUTT*QQ?*GEUسH(@=dAi3u7 9  I$@+ϿQQ?*쏊*?*쏊*?*-?*쏊*?*쏊*?*쏊z쏊*?*쏊*?*쏊*8r.O/js)%}wO@]eyZJЯ>[Q Եc^< yj4-.pAڏir d!-p&@]k;OW8 c*S;8 vcB= : ]S`y ;QeOc=z JA%Re윇8d"c99d[Zd߸hߪ1&;mo	
`Axv9knl߆1B@x7Vy*sZ_NV( -?q$aq?$4
 _b@( ϟOiQƝ'Pr
0V?b{_S$ƍ_5 F7{_o#Egrro?dR5:d
 ŨLzM;n+~PNc	* JW OzГjΡP+ O^yT@P ۩gLw3  <[~oU V* `Գڻ0  muoC U 5kJx3  X :Z[=?  , v̬3U}  [ o7U  - v̬=U}.( ` nG!ކ'  oIն
 0޼T 
 0Eg V& @kȩ0|   H  5>< " `CS 
 q:J O/ # W s ~#US V *JVT!R 
 fvh  `GǒU0 	 =RRL % 3'?Ho  ,R}d	 < Ͼz|T;_2 )P^9!7 H_|?RՁ_  u?HT[B,jGF+zoT,LjB*uTTTVSBeHq"F 1*p)JH xGoU_$  R[|TB_(վHx   T, %  j,QJH HϏs[E   hg|:՟
TN_KX۴  B=s'e?˧j,!ԦDU'm</Ç?bggIw]eHe   TڗWJ*/'Wn㌦
V$No	Y%m7y7PB`}A  P_ӰJf匪l)>D  '[%Rs&?  *3ĶlVZ..( @W~Ϫq;_.&s&^+ju!!T*ӿhV+||t
B ƲJ6e4]b  BeǪi2)na  ~z*ܗ(`ǁ  B5?_*iiWx٢Ve[⭦>fc1Z)EJJ)caߞ|z`R+F KUStȜjJ]o' .[ (A UiﬦJƁE[   BmJfjTqS9VV'    jrNI$UΧx[A:    RV3$*(ˀa<   ۿV~LZ*Uma20r   Z*~N-v##zJ    VǯOj]    KXU꧸$WK@'A    :bRHg/ ު0   !|f(T1 Ve    VM!Mx.o0V4    iۿfdۛPrV    |&kvRNw,@تe    /fUo3j2୊    JrPUGϑjo x   )&FˀFԪB   `U;gK?20   g_ʪ)1S%; -e!  Y~79,0r%d!@P   0CwrV/S5(@    b_Ȫ	b?U}YO  `
EU! WVY 4 W:1j,   @UUDhdU(!   i0P^   z$cUjy%c~    @"Vtv<T=   KXxJS5,  yVJ߲Zj*   L> Z*KFa5ը\	X~^   V0UFԱ3V    PUW
X]/վ*5VG    t[?Joㄣ    x՜V7SzF8O   @3[~?DV)*    , 8UUD?&(ԬV    V5&T/۪y5T   0fmS_|7  _z O!_q   ٪bξ>T	V;k   P pK0O>    Vk} x8lj1    n^  V|krc     pF.mu^    y-WAg)S!8vi9]2=gF#	3DԺ|? >/~Lu4   ,QLny_ h7qL0X
 %z˔ @n-1  $JS) ]S3⤷   aÔi߮5Duwz  QjUF@K:TX iaiOú<N>[,?Ƚ2B?}N/	秖VH\8^D 0)4T̐ _> T ӈOH.QVE P`7A[qop@J[Ѥ^ k,.x/c*c={9 I*h  
KV=| ̱@ qe٠;T,H  46Wt<0_ 	:(  t&@r_ 	p<Y  +  IbQ  lM
 W_ p%E@  h  3)   @f/ Hd0 "N-9dg4RY0 UI  {&e@TVZ̃w~ |c` U7S:oW 09peQ Y	G @0w
H oV	 6@V5 y ̧,K U{J 'CJ> Uc4 8
豵  D`Ւ yV X
 1Xu߫wu1@V-@]* H3h pBL _KF`u UӠ 6RopV`- nՎCF_ 韯 *{, ̤\c
  lU~ ) N6 X ![Uz  L
L`ڳg䤉 `,uy *~H kC @ Ԫ={cK% c2S  P:ƻL /k P 	 RK  @V'   b$rc- iUvTT XIjN@ Ϫ` I=$ Z\  () U!   Th\S  ,n J{b
  gUr TENЬJN 6( ,uW,~ *7) ֖:V BjM f|Z@ X]*3D@. dU  ./2n
  cUqv V
E@M2  ԛ 7 {g69(JI#vdٻUO.,;gAQȿYUpy?	 j3;`%u 	5@mڡӻ;  #=ZJQ Dξb+fw 7kqgI>Kk[oO>>ð71 JQ!V  0eo
|4:vN U@c>.H5::@Pʯ n6X4Mѭ(: @֜̵?_Ckw y4鏵  x)gOq3ۛ}m Фb4bcƊ`O Zl  i-dگqV@"5 tۂu?Ň1ߦ:'O&5>$A<5:@Č, @T qF[C   h  j0L> 4m $ T?o}URC~'3#CAƦ d@T?}٬ϥ&3;  R<7 8B RMᏂ!T 8 L- arO!  Q h b=Ow?	٧:K]qWh2`0  .X 1dw~JR8 q! ?xz։y  +GZ@ZQ?=$.lT  r \oa0hj
D*0S?  F@L?|Ձx8s4
 d  ?=`A^~W]~Ts> c`?9T JmT]ZW r   h,ng>L 	L`$  3揢x+Vs0w m C p (ŭKEz   hcqkND˥.k8`_ `2 W`D*;6s @3 2Cwv@2   :-hkr?  S`5 ȴЌJ._4`k |P̾u 4,JO~/qDj:4'K2#9: Z@ĒAm+hh4?$$  5ae@ @c )'y}U   H^'7h h oX5yVR@ˀ= h I-_|J  5I{ 9 &P&RZ>( RF: T@oR?WE	pg m M@mGf T`  Rm?* 00J-7iU`Qǭ d=JT?Lǥ#qe -' `{L3祾'@F@ C[@; yc_. l g*df Jyf T`p59 _p Ne 6_2^WX0I @# 8輅2 	/\:^*E { 8 rAk,N?e_TDPNR@H ?0K$Q . ~Z>e =S&@ Ћ M[Y!erō3BH" 
nHO  ,*KMT_As	@ P1RKv!KHRHI @Ov T`+ુ,c  T)(%ʥB	X-nrL"r 43T6;=oRR'(e@ C S ; `媋"&_N	 
md* @*Qɶ'\9 @֞	5Y|U5
z29 owY T 	8^*XN 8Cg6}@Igӗa2T	:;  ӗ  R$ *V (@Tr,-@6M uǠ@ؿ j! +(T @~}T`0|U8Ke Y@K 8 %dDW -\5 TDxTP7 oEKϪV @%c 70@O_! -~P9 fCJj& П#Rusi  Ԃ k ^*Ref-X9 m qo T Ԃ=}w T h?I5  P
'P7 =S실2g JW ; lL+  RgLjA 0 Pa@m^*1\TjbZWv TT0sCՂU,pP}P5 ":Ek }aGP5 f.PJk֮:P.zr
  =o2@Ƽ  R 0  h+<J2:  P+'[% ]@oIaxT(6@A   3Rq#bgX e9  5Av T zZk@*{l,I8 |M%gUV  Th@  1{ଊ|JE7GR*  @@ٿ3 X*T {v  Txxd0 Rv   /H 
J@Mw  ;OR RKk  +	< J  5 Ԛ6g/$$4@k?eS1 4IԲc@ ̀DdW	 [;P MH^o ޜY@  	{$\ g;P- ^y'@*pެq h,%$8   RxI M
 v  :p?S  /- R?N` @dqc3B/VAw98  v 'D! k7!  =RڂR& `,Rٵq, 8 #|PaVg
B Ƹ+bb /W~ r@iu{ p |ɷC #ԅ x\D>> &W@o
 @j  2+x B T}  +< ;E { >`Ģw͹i  8  p \*Pyh o  ,0  G;  > K  #+*N XL ` U{  +:_u\;    p 8    p8   @÷SU_ p p M ۀs×T }8   @= =}8 N}S 8br x[ط/=3w=5~} 8 ^~,_# f [͵ x_?৿  b?#(   bM.{^i4)(e Y@ZuB[x DD d` $ZCj]29v> LJ
H8   lBN? 5U>* xH$   ~W
xg`KzĬ pnfM6fgT*&v *|^Q@|9R 4`rqUV1] 4#QUj  7i]nr] xVwY`*	   ;_o 'MoL:-~/: *w&̒\? xR`
 H @ C  5mxW  I   rZAch^*w,  x608f`j MH ' N~
2	qT>T28"
DT
4Yo |.pX' @D{ 8 $Xc,9Z l2RGX5  SOdKjhGFjAYӪ 80/p RM!=  b+hZ ZԾ*v p t̧T*| HjG@)  6 oQ0R%- /P?Ӫ H{l@9p 
Je)= =vT` zF3 { @{g(%[FjAp  x*2OH smɽ{ 8 }@\eJjAp: $ "R9  (U H-cj  EY ` gU p P/#d8RU R* DHjA.1l H
g  T  ( p @= $~LԂ   n/,9SK-+
 C #RM { 8 :؝
 + 8=}&@ p 
u ,Q  :@L  5|' ]A  J: DNjAp-@+;Nj] |7R`h C!@Pj/t+` @^ -/(   %oe$5 \ RUL~ 8 >0;/U= RR,' sWLP~gsY&m`-DP  8@ٟӅJ-CK [LjP- 8 ڙZP R_5j \=*9 ]奞)E	 8 (e|m k2P%QQ}i_ʕҏ6 F[6i  m>R9 @jmZ  z,f(cn 3 HD{ 8 MAdaSA8m'UT 6T	`  (LK-Pj.V Qn  uLLV #`Oy8SUm3 p H G5vh"5`YӤ  ?:V`5FjK̿j  !w T~\
lZ R@  ^8Upt<x^ $oTG
{#& *V)@V* ME   |ۿyT~7V@O R}\`9@T?>T0Ė}W "׺ ?$E% 8 :,3GL /n6 hlB/T O t؛J|[hh8 fe(H9^X7h TJvOY5 `d {LO5 @JAg)Ư XO  ~oޜH	lF`R3uLPK󄓔Mm Pj#Pv! Aɶ9 8 @(T F@ H]OGؽW% aAU1 ὖSY;sM ojpH	o- K=pǥgMh  ,~ 
,ӿ p/AI p ,\O!R 2.
t[C5,[Z%dme<PjAb "k2
@2`H*Ty !5 @Ru & \ ?+4~0p?ӣh `$  x
 Ԃvw [Nc9Tj? ܱ
wX_UsӍ  X 4)&:Əpax: 'q@gm$C \*yȯtߟRJ,  Q	 T(0 1_5Gcjq|F]>) 8 d؝`\4F\*(a4r5 2
   JIʥ~C2 <KGن H:icyyssfi.9@ a 8 4HdP1ooV^j6󱋖  @_ 8k4 Riجcpӟw 4 MqO0R c&-BXŮ뷟?? | ǾS p c$C:w_F~ӟw 4 xU  CcP 96 m煆 59l`ǴYjt;2 HyЃe@cWeuH  n|+>6V8΅,.u tB1kx["ژU  Z`fhk"e= 2G}r~Xt#0e v (_>nVot),
~ܧ d`: @KRΧ&zQ 15 4 P/X Ռݗ?;J 
 7phn!ޯv/9ymbh̹pi  Ϗ}oKc'z	
];V18 ut h`ʦ[JV 'z\A;[ ڍ`=s18 ,&9@ꀃBꁭ jfvU_ eM .()!@|8 .*5d@WU x]qp \Zꀵ^w ^I e# @  U{50Y2$paqk 8 wD cpIL  P!IrR@ D@'ct \J tYhG@4TQ|ܔʸP_{L;уx9Y֒	?T[ B0,jAO p Po 	jMO p PomI OX	 n ~jh|'**   4TF N B @ k{# /[+ x[w.* *@; VFƟ.. *@;[w	pQǡ󽿯IKꋱO ZIߪ vIVAPՋK<u!" :Tt3% 6 @C{;n 7X x1 # @`* xX: p P>llIs|n ު Ph?~7 ^lY6 @Zc7R UQ Y {IU"* i1
WA )D I
 <
?Ԭ K5` Jna>? C lY?dmBUA H%TC: E# c3Z Nnԉ- \?vBQO| yt ۤު PR+
- @gNU 
 i9D. \qEbX `oF ?xlb  XrG  %mF   ꀷ4 @g'%x" $m  tfY- 
 ի 	`iN! hNZCcA  BI) @g)Xe Dު || cAP	  jթ}^ 4YI @h<|  |NxV;N ЃP=H Q@'<A@ ֹ]9OS]]҇tq8$ f\	KЋt
$s]]ak $o:s%4՗vM (	8ωC:6( @37_+Ž Pǀ	VǏuXF5Xe .4p- N[`vWiYR-  k?ZDCu:hL  $˳ m! Pju wX`Z *j/B /  #pNP  7QWy`+Q-t	nni9jnD#8PI [b1$F7rk6 ILm 7F ^!9jp !#Gǃ   N5TĨ JbTaܨZ >F91Տ.QO[kH߾ѣ>, yA@  {Q#W ѣ6   }QCIB< 8>U'   X?jGW? 8Ǐ*\  0,b;*nB 	@e"K !	4G 5EԎz@Q/C 灨IU9ꡱ! PN<   SDՏ Z"j= @'DՆz(F[7IJC /D%Q-^RDe/ 
Divԇk6+ ۘ?ATB =*&jpԇ) Q&[ &xPi{Q+G! 
(RE%R_!U~ @ ,vK!j|s/   zG,j
Q_zoEm>e@  JS\}w*]Ԇ  7@~JVotQ;@ o}H?$.ӷ|	[U`)JW]cqQ NUPjCL2*#?`*H3PkjUt6eT_FjVmSQ6mT?`v 	(
VUk(JGB 4`Q(ebɭx:j|!  D^2[YI֟Gd! IUyzbV*  HU^%L_PV円?qf _Gn	9*?sZ5 4g!  Ee
`j1o6+̀0  7@Ҩ UjU`:; \? pSEg29u9~? TQՅqZNժ
CôjU   n '&0elV,l lԎ`¨FUd*IVfEEՄ @ @N5~*YDRuvf P*3 FUGcn/[ZRgEevLz P*7@3u[<+VY>Ӫ@ ɣZ]<J)!OT+JiEdvN J>*w@BxI@'_tqQ9@8DaVӂRcP3EUfwjP-jЭԯl8.`V!Yp3̼?s%fu
P-y54Լ *[Dω~U˙sε} @1EDUYc y_C (WQ5\K?|fu 9Vv[q] %fXˀwZ]φ^qg'a7 Y? ږv3Ν?]ORU`)X_]ԯ݂A (ۀ TQfQ  1H˯ha  Jb|Q!_!hufPjG_ 8TmhuLDE Pjpixd@s(ޢŀRo*ۀR$'*ۀwZ}Y?R!h~dIkyhh6ԃՅR;	ރr{rAQ@^0 gsZl1o/Ъ*o~7,J{h-WQ՗
@+^ j{ %j"hg~YZQ
2{".GhUD:{oW6  @7? wԋkO <E?Vc-z  b
@l? * _/W>  qW?zj  \j?ng  @xVOE  OL!jK   v(cZ @ 
(iU<og  pzڟ? E)[UC `?\(NUj:L!٪C P UZ t-J3 x:G/
V?_ <׎^ebxL APj^>  _4R*  JQr]7  \VҪeOn1  P*^a  '8UR[*" 8;VUS1  ?nZLVN .teܭ}~i ՞n:djVf݈,V t3eQWt3peT^*~) O lV]Qɶ pe~WcbWbDƿ}1  ?hOTVҾ>Jgyl -,|Z)%_o(:š|z`b  e ptq`\> pA9~ O˺pGp1  ǟN1>rُ 8QY{ğI3*vD Uv~6@ ?Zoퟏ;--`Q! D;v=`\{c  X轻khuQ! DRns.Zɿg 0DCw׼'UQeTTUGEQQeTTUGEQQeTTUGEmeTTUGEQQeTTUGEQQeTTUGEQQ+UGEQQeTTUGEQQeTTu 2II$@ u*?*쏊*?*j*?*쏊*?*쏊*?*쏊?*쏊*?*쏊*?*쏊*?*쏊*?*쏊*?*쏊*쏊*?*쏊*?*쏊*?*j+?*쏊*?*쏊*?*쏊?*쏊*?*쏊*?*쏊*?*쏊*?*쏊*?*쏊*쏊*?*쏊*?*쏊*?*j1?*쏊*?*쏊*?*쏚?*zۣ   a[A	TT*QQ?*GEUUTT*QQ?*GEUTTTT*QQ?*GEUTTTT*QQ?*GEUUTT*QQ?*GEU~m+pf6    IENDB`
===== FILE: mobile/package.json =====
{
  "name": "baku-reserve-mobile",
  "version": "1.0.0",
  "main": "index.ts",
  "scripts": {
    "start": "expo start",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web"
  },
  "dependencies": {
    "@react-native-community/datetimepicker": "8.4.4",
    "@react-navigation/native": "^7.1.18",
    "@react-navigation/native-stack": "^7.5.0",
    "expo": "~54.0.18",
    "expo-constants": "~18.0.10",
    "expo-status-bar": "~3.0.8",
    "react": "19.1.0",
    "react-dom": "19.1.0",
    "react-native": "0.81.5",
    "react-native-gesture-handler": "~2.28.0",
    "react-native-safe-area-context": "~5.6.0",
    "react-native-screens": "~4.16.0",
    "react-native-web": "^0.21.0"
  },
  "devDependencies": {
    "@types/react": "~19.1.0",
    "typescript": "~5.9.2"
  },
  "private": true
}

===== FILE: mobile/src/api.ts =====
export const API_URL = 'http://192.168.0.148:8000';

export async function fetchRestaurants(q?: string) {
  const url = q ? `${API_URL}/restaurants?q=${encodeURIComponent(q)}` : `${API_URL}/restaurants`;
  const res = await fetch(url);
  if (!res.ok) throw new Error('Failed to fetch restaurants');
  return res.json();
}

export async function fetchRestaurant(id: string) {
  const res = await fetch(`${API_URL}/restaurants/${id}`);
  if (!res.ok) throw new Error('Restaurant not found');
  return res.json();
}

export async function fetchAvailability(id: string, dateStr: string, partySize: number) {
  const url = `${API_URL}/restaurants/${id}/availability?date=${encodeURIComponent(dateStr)}&party_size=${partySize}`;
  const res = await fetch(url);
  if (!res.ok) throw new Error('Failed to fetch availability');
  return res.json();
}

export async function createReservation(payload: {
  restaurant_id: string;
  party_size: number;
  start: string;
  end: string;
  guest_name: string;
  guest_phone?: string;
  table_id?: string;
}) {
  const res = await fetch(`${API_URL}/reservations`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload)
  });
  if (!res.ok) {
    const txt = await res.text();
    throw new Error(txt || 'Failed to create reservation');
  }
  return res.json();
}

===== FILE: mobile/src/components/RestaurantCard.tsx =====
import React from 'react';
import { View, Text, Image, Pressable, StyleSheet } from 'react-native';
export default function RestaurantCard({ item, onPress }: any) {
  return (
    <Pressable onPress={onPress} style={styles.card}>
      {item.cover_photo && <Image source={{ uri: item.cover_photo }} style={styles.cover} />}
      <View style={{ flex: 1 }}>
        <Text style={styles.title}>{item.name}</Text>
        <Text style={styles.sub}>{item.cuisine.join(' • ')}</Text>
        <Text style={styles.city}>{item.city}</Text>
      </View>
    </Pressable>
  );
}
const styles = StyleSheet.create({
  card: { flexDirection: 'row', gap: 12, padding: 12, borderWidth: 1, borderColor: '#eee',
          borderRadius: 12, marginBottom: 8, backgroundColor: 'white' },
  cover: { width: 90, height: 70, borderRadius: 10 },
  title: { fontSize: 16, fontWeight: '600' },
  sub: { color: '#666', marginTop: 2 },
  city: { color: '#999', marginTop: 2 }
});
===== FILE: mobile/src/config/api.ts =====
/**
 * Minimal fetch wrapper for the mobile app.
 * API_URL comes from Expo "extra" (see app.json), but we allow fallback for dev.
 */
const API_URL =
  (typeof globalThis !== "undefined" &&
    // In dev with Expo SDK 49+: Constants.expoConfig?.extra
    // In production (EAS/Updates): Constants.manifest?.extra (legacy) or runtime env
    (globalThis as any)?.EXPO_PUBLIC_API_URL) ||
  process.env.EXPO_PUBLIC_API_URL ||
  "http://192.168.0.148:8000";

const full = (path: string) => {
  if (!path.startsWith("/")) path = `/${path}`;
  return `${API_URL}${path}`;
};

async function handle(res: Response) {
  const text = await res.text();
  const data = text ? JSON.parse(text) : null;
  if (!res.ok) {
    const msg = (data && (data.detail || data.message)) || res.statusText;
    throw new Error(`API ${res.status} ${msg}`);
  }
  return data;
}

export const api = {
  base: API_URL,
  url: full,
  get: (path: string, init: RequestInit = {}) =>
    fetch(full(path), { ...init, method: "GET" }).then(handle),
  post: (path: string, body: any, init: RequestInit = {}) =>
    fetch(full(path), {
      method: "POST",
      headers: { "Content-Type": "application/json", ...(init.headers || {}) },
      body: JSON.stringify(body),
      ...init,
    }).then(handle),
  del: (path: string, init: RequestInit = {}) =>
    fetch(full(path), { method: "DELETE", ...init }).then(handle),
};

===== FILE: mobile/src/debug/probe.ts =====
import { api } from '../src/config/api';

export async function probeBackend() {
  const health = await api.get('/health');
  console.log('[probe] health:', health);

  const list = await api.get('/restaurants');
  console.log('[probe] restaurants:', list.length, list?.[0]);
}

===== FILE: mobile/src/screens/BookScreen.tsx =====
import React, { useEffect, useState } from 'react';
import { View, Text, TextInput, FlatList, Pressable, ActivityIndicator, Alert, StyleSheet } from 'react-native';
import { fetchAvailability } from '../api';

function todayStr() {
  const d = new Date();
  const y = d.getFullYear();
  const m = String(d.getMonth()+1).padStart(2,'0');
  const day = String(d.getDate()).padStart(2,'0');
  return `${y}-${m}-${day}`;
}
function timeFromISO(iso: string) {
  const d = new Date(iso);
  return d.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
}

export default function BookScreen({ route, navigation }: any) {
  const { id, name } = route.params;
  const [dateStr, setDateStr] = useState<string>(todayStr());
  const [partySize, setPartySize] = useState<string>('2');
  const [loading, setLoading] = useState<boolean>(false);
  const [slots, setSlots] = useState<any[]>([]);

  async function load() {
    try {
      setLoading(true);
      const ps = parseInt(partySize || '2', 10) || 2;
      const data = await fetchAvailability(id, dateStr, ps);
      setSlots(data.slots || []);
    } catch (e: any) {
      Alert.alert('Error', e.message || 'Failed to load availability');
    } finally {
      setLoading(false);
    }
  }

  useEffect(() => {
    navigation.setOptions({ title: `Book · ${name}` });
    load();
  }, []);

  function openSeatPicker(slot: any) {
    const ps = parseInt(partySize || '2', 10) || 2;
    navigation.navigate('SeatPicker', { id, name, partySize: ps, slot });
  }

  return (
    <View style={styles.container}>
      <View style={styles.filters}>
        <View style={styles.row}>
          <Text style={styles.label}>Date (YYYY-MM-DD)</Text>
          <TextInput value={dateStr} onChangeText={setDateStr} style={styles.input} autoCapitalize="none" />
        </View>
        <View style={styles.row}>
          <Text style={styles.label}>Party Size</Text>
          <TextInput value={partySize} onChangeText={setPartySize} keyboardType="number-pad" style={styles.input} />
        </View>
        <Pressable onPress={load} style={styles.button}><Text style={styles.buttonText}>Find slots</Text></Pressable>
      </View>

      {loading ? <ActivityIndicator style={{ marginTop: 16 }} /> :
        <FlatList
          data={slots}
          keyExtractor={(_, idx) => String(idx)}
          renderItem={({ item }) => {
            const count = item.count || 0;
            return (
              <View style={styles.slot}>
                <Text style={styles.slotText}>{timeFromISO(item.start)} – {timeFromISO(item.end)}</Text>
                <Text style={styles.count}>{count} tables</Text>
                <Pressable
                  onPress={() => openSeatPicker(item)}
                  disabled={count === 0}
                  style={[styles.bookBtn, count === 0 && { opacity: 0.4 }]}
                >
                  <Text style={styles.bookText}>Select table</Text>
                </Pressable>
              </View>
            );
          }}
          ListEmptyComponent={<Text style={{ marginTop: 12, color: '#666' }}>No slots. Try another time or party size.</Text>}
        />
      }
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, padding: 12, backgroundColor: '#fff' },
  filters: { gap: 8, marginBottom: 8 },
  row: { gap: 4 },
  label: { fontWeight: '600' },
  input: { borderWidth: 1, borderColor: '#ddd', borderRadius: 8, padding: 10 },
  button: { backgroundColor: '#111', padding: 12, borderRadius: 10, alignItems: 'center', marginTop: 6 },
  buttonText: { color: '#fff', fontWeight: '600' },
  slot: { flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between',
          borderWidth: 1, borderColor: '#eee', borderRadius: 12, padding: 12, marginBottom: 8 },
  slotText: { fontSize: 16, fontWeight: '500' },
  count: { color: '#666', marginRight: 12 },
  bookBtn: { backgroundColor: '#0a7', paddingVertical: 8, paddingHorizontal: 12, borderRadius: 8 },
  bookText: { color: 'white', fontWeight: '600' }
});

===== FILE: mobile/src/screens/HomeScreen.tsx =====
import React, { useEffect, useState } from 'react';
import { View, TextInput, FlatList, ActivityIndicator, StyleSheet } from 'react-native';
import { fetchRestaurants } from '../api';
import RestaurantCard from '../components/RestaurantCard';
export default function HomeScreen({ navigation }: any) {
  const [loading, setLoading] = useState(true);
  const [query, setQuery] = useState('');
  const [data, setData] = useState<any[]>([]);
  async function load(q?: string) {
    setLoading(true);
    const items = await fetchRestaurants(q);
    setData(items);
    setLoading(false);
  }
  useEffect(() => { load(); }, []);
  return (
    <View style={styles.container}>
      <TextInput style={styles.search} placeholder="Search restaurants or cuisines…"
                 value={query} onChangeText={setQuery} onSubmitEditing={() => load(query)} />
      {loading ? <ActivityIndicator /> :
        <FlatList data={data} keyExtractor={(item) => item.id}
          renderItem={({ item }) => (
            <RestaurantCard item={item}
              onPress={() => navigation.navigate('Restaurant', { id: item.id, name: item.name })} />
          )} />}
    </View>
  );
}
const styles = StyleSheet.create({ container: { flex: 1, padding: 12 },
  search: { borderWidth: 1, borderColor: '#ccc', borderRadius: 8, padding: 10, marginBottom: 8 } });
===== FILE: mobile/src/screens/RestaurantScreen.tsx =====
import React, { useEffect, useState } from 'react';
import { View, Text, Image, ActivityIndicator, StyleSheet, Pressable, Alert } from 'react-native';
import { fetchRestaurant } from '../api';

export default function RestaurantScreen({ route, navigation }: any) {
  const { id } = route.params;
  const [data, setData] = useState<any>(null);
  const [loading, setLoading] = useState<boolean>(true);

  useEffect(() => {
    (async () => {
      try {
        const r = await fetchRestaurant(id);
        setData(r);
        navigation.setOptions({ title: r.name || 'Restaurant' });
      } catch (e:any) {
        Alert.alert('Error', e.message || 'Failed to load');
      } finally {
        setLoading(false);
      }
    })();
  }, [id]);

  if (loading) return <ActivityIndicator style={{ marginTop: 20 }} />;
  if (!data) return <Text>Not found</Text>;

  return (
    <View style={styles.container}>
      {data.photos?.[0] && <Image source={{ uri: data.photos[0] }} style={styles.cover} />}
      <Text style={styles.title}>{data.name}</Text>
      <Text style={styles.sub}>{(data.cuisine || []).join(' • ')}</Text>
      <Text style={styles.addr}>{data.address || ''}</Text>
      <Text style={styles.phone}>{data.phone || ''}</Text>

      <Pressable
        onPress={() => navigation.navigate('Book', { id: data.id, name: data.name })}
        style={styles.bookBtn}
      >
        <Text style={styles.bookTxt}>Book a table</Text>
      </Pressable>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, padding: 12 },
  cover: { width: '100%', height: 180, borderRadius: 12, marginBottom: 12 },
  title: { fontSize: 22, fontWeight: '600' },
  sub: { marginTop: 4, color: '#555' },
  addr: { marginTop: 8 },
  phone: { marginTop: 4, color: '#333' },
  bookBtn: { marginTop: 16, backgroundColor: '#111', padding: 12, borderRadius: 10, alignItems: 'center' },
  bookTxt: { color: '#fff', fontWeight: '600' }
});

===== FILE: mobile/src/screens/SeatPicker.tsx =====
import React, { useEffect, useState } from 'react';
import { View, Text, FlatList, Pressable, Alert, StyleSheet } from 'react-native';
import { fetchRestaurant, createReservation } from '../api';

type Slot = { start: string; end: string; available_table_ids: string[]; };

export default function SeatPicker({ route, navigation }: any) {
  const { id, name, partySize, slot }:{ id:string; name:string; partySize:number; slot:Slot } = route.params;
  const [tables, setTables] = useState<any[]>([]);
  const [loading, setLoading] = useState<boolean>(true);

  useEffect(() => {
    navigation.setOptions({ title: `Choose table · ${name}` });
    (async () => {
      const r = await fetchRestaurant(id);
      const map: Record<string,{id:string; label:string; capacity:number}> = {};
      for (const area of r.areas || []) {
        for (const t of area.tables || []) {
          map[t.id] = { id: t.id, label: t.name || `Table ${String(t.id).slice(0,6)}`, capacity: t.capacity || 2 };
        }
      }
      const list = (slot.available_table_ids || []).map(
        (tid:string) => map[tid] || {id:tid, label:`Table ${String(tid).slice(0,6)}`, capacity:2}
      );
      setTables(list);
      setLoading(false);
    })();
  }, [id]);

  async function book(tid: string) {
    try {
      const res = await createReservation({
        restaurant_id: id,
        party_size: partySize,
        start: slot.start,
        end: slot.end,
        guest_name: 'Demo Guest',
        guest_phone: '+994500000000',
        table_id: tid
      });
      Alert.alert('Booked!', `Reservation ID: ${res.id}`);
      navigation.goBack();
    } catch (e:any) {
      Alert.alert('Could not book', e.message || 'Unknown error');
    }
  }

  if (loading) return <View style={{padding:16}}><Text>Loading tables…</Text></View>;

  return (
    <View style={styles.container}>
      <Text style={styles.subtitle}>Pick a table for {new Date(slot.start).toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'})}</Text>
      <FlatList
        data={tables}
        keyExtractor={(x) => x.id}
        renderItem={({ item }) => (
          <View style={styles.row}>
            <Text style={styles.tlabel}>{item.label}</Text>
            <Text style={styles.cap}>cap {item.capacity}</Text>
            <Pressable onPress={() => book(item.id)} style={styles.btn}>
              <Text style={styles.btntxt}>Book</Text>
            </Pressable>
          </View>
        )}
        ListEmptyComponent={<Text style={{color:'#666'}}>No tables free.</Text>}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex:1, padding:12, backgroundColor:'#fff' },
  subtitle: { marginBottom: 8, color:'#444' },
  row: { flexDirection:'row', alignItems:'center', justifyContent:'space-between',
         borderWidth:1, borderColor:'#eee', borderRadius:12, padding:12, marginBottom:8 },
  tlabel: { fontWeight:'600' },
  cap: { color:'#666', marginRight:12 },
  btn: { backgroundColor:'#111', paddingVertical:8, paddingHorizontal:12, borderRadius:8 },
  btntxt: { color:'#fff', fontWeight:'600' }
});

===== FILE: mobile/tsconfig.json =====
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true
  }
}

===== FILE: .github/workflows/ci.yml =====
name: CI
on:
  push:
  pull_request:

jobs:
  backend-regression:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install backend deps
        working-directory: backend
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Launch API (background)
        working-directory: backend
        run: |
          nohup uvicorn app.main:app --host 127.0.0.1 --port 8000 >/tmp/api.log 2>&1 &
          for i in {1..30}; do
            curl -fsS http://127.0.0.1:8000/health >/dev/null && break
            sleep 1
          done
          curl -fsS http://127.0.0.1:8000/health

      - name: Run full regression
        env:
          BASE: http://127.0.0.1:8000
        run: bash backend/full_regression.sh

      - name: Upload API log on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: api-log
          path: /tmp/api.log

===== FILE: code_dump/STRUCTURE.txt =====
# Repo structure (filtered)
# Root: /Users/jkazimzade/baku-reserve

.
  dump_code.sh
  dump_code.py
backend
  backend/backend_smoketest.log
  backend/backend_smoketest.sh
backend/app
  backend/app/models.py
  backend/app/__init__.py
  backend/app/seed.py
  backend/app/schemas.py
  backend/app/utils.py
  backend/app/storage.py
  backend/app/main.py
  backend/app/availability.py
backend/app/data
  backend/app/data/reservations.json
code_dump
  code_dump/STRUCTURE.txt
===== FILE: dump_app_only.py =====
import os, sys, time, json, re
from pathlib import Path

# ---- CONFIG: what to include ----
BACKEND_WHITELIST_DIRS = ["backend/app", "backend/tests", "backend/scripts"]
BACKEND_WHITELIST_EXTS = {".py", ".toml", ".ini", ".cfg", ".md", ".txt", ".yaml", ".yml"}
BACKEND_SINGLE_FILES    = [
    "backend/requirements.txt",
    "backend/pyproject.toml",
    "backend/requirements-dev.txt",
    "backend/.env.example",
    "backend/.env"
]

FRONT_WHITELIST_DIRS = [
    "app", "src", "components", "screens", "hooks",
    "navigation", "utils", "constants", "services", "api"
]
FRONT_WHITELIST_EXTS = {".ts", ".tsx", ".js", ".jsx", ".json", ".md", ".yaml", ".yml", ".mjs", ".cjs"}
FRONT_SINGLE_FILES   = [
    "App.tsx", "App.js", "package.json", "app.json", "app.config.js", "app.config.ts",
    "tsconfig.json", "babel.config.js", "metro.config.js", "eslint.config.js",
    "eslint.config.cjs", "prettier.config.js", "prettier.config.cjs", ".env", ".env.example"
]

SKIP_DIRS = {".git", "node_modules", ".venv", "__pycache__", ".expo", ".next", "ios", "android", "build", "dist", ".idea", ".vscode", ".pytest_cache", ".mypy_cache"}

def is_text(p: Path) -> bool:
    try:
        with p.open("rb") as f:
            chunk = f.read(2048)
        chunk.decode("utf-8")
        return True
    except Exception:
        return False

SECRET_PATS = [
    (re.compile(r'(?i)\b(password|pwd|pass|secret|token|api[_-]?key)\s*[:=]\s*\S+'), r'\1=***REDACTED***'),
    (re.compile(r'(?i)\b(database_url|db_url|database_uri|connection_string)\s*[:=]\s*\S+'), r'\1=***REDACTED***'),
]

def redact(s: str) -> str:
    for pat, repl in SECRET_PATS:
        s = pat.sub(repl, s)
    return s

def dump_files(root: Path, rel_paths, out_file: Path):
    out_file.parent.mkdir(parents=True, exist_ok=True)
    with out_file.open("w", encoding="utf-8") as out:
        out.write(f"# App-only dump\n# Root: {root}\n# Generated: {time.strftime('%Y-%m-%dT%H:%M:%S')}\n")
        for rel in rel_paths:
            p = root / rel
            if not p.exists():
                continue
            if p.is_dir():
                for dp, dn, fn in os.walk(p):
                    dn[:] = [d for d in dn if d not in SKIP_DIRS]
                    for name in fn:
                        fp = Path(dp) / name
                        if fp.suffix.lower() not in BACKEND_WHITELIST_EXTS and fp.suffix.lower() not in FRONT_WHITELIST_EXTS:
                            continue
                        if not is_text(fp):
                            continue
                        out.write(f"\n===== FILE: {fp.relative_to(root)} =====\n")
                        try:
                            txt = fp.read_text(encoding="utf-8")
                        except Exception:
                            out.write("# [unreadable]\n")
                            continue
                        out.write(redact(txt))
                        if not txt.endswith("\n"):
                            out.write("\n")
            elif p.is_file():
                if p.suffix.lower() not in BACKEND_WHITELIST_EXTS and p.suffix.lower() not in FRONT_WHITELIST_EXTS:
                    continue
                if not is_text(p): 
                    continue
                out.write(f"\n===== FILE: {p.relative_to(root)} =====\n")
                try:
                    txt = p.read_text(encoding="utf-8")
                except Exception:
                    out.write("# [unreadable]\n")
                    continue
                out.write(redact(txt))
                if not txt.endswith("\n"):
                    out.write("\n")

def main():
    root = Path(sys.argv[1]).expanduser().resolve() if len(sys.argv) > 1 else Path("~/baku-reserve").expanduser().resolve()
    out_dir = root / "code_dump"
    out_dir.mkdir(exist_ok=True)

    # BACKEND
    backend_dirs = [d for d in BACKEND_WHITELIST_DIRS if (root / d).exists()]
    backend_files = [f for f in BACKEND_SINGLE_FILES if (root / f).exists()]
    if backend_dirs or backend_files:
        dump_files(root, backend_dirs + backend_files, out_dir / "APP_BACKEND.txt")
        print(f"[i] wrote {out_dir / 'APP_BACKEND.txt'}")
    else:
        print("[i] No backend whitelist matches here")

    # FRONTEND: detect a JS/Expo root (either ./mobile or the root itself if it’s a JS app)
    js_roots = []
    for cand in [root, root / "mobile", root / "frontend"]:
        if (cand / "package.json").exists():
            js_roots.append(cand)

    if not js_roots:
        print("[i] No JS root (package.json) at", root, "or ./mobile")
    else:
        for idx, jroot in enumerate(js_roots, 1):
            rels = [d for d in FRONT_WHITELIST_DIRS if (jroot / d).exists()]
            files = [f for f in FRONT_SINGLE_FILES if (jroot / f).exists()]
            if not rels and not files:
                print(f"[i] JS root {jroot} has no whitelisted app dirs/files")
                continue
            outfile = jroot / "code_dump" / (f"APP_MOBILE_{idx}.txt" if jroot != root else "APP_MOBILE.txt")
            dump_files(jroot, rels + files, outfile)
            print(f"[i] wrote {outfile} (from JS root {jroot})")

    print("[i] DONE")

if __name__ == "__main__":
    main()

===== FILE: dump_code.py =====
import os, re, sys, time, json

ROOT = os.path.abspath(sys.argv[1]) if len(sys.argv) > 1 else os.path.expanduser("~/baku-reserve")
OUT  = os.path.join(ROOT, "code_dump")
os.makedirs(OUT, exist_ok=True)

SKIP_DIRS = {".git","node_modules",".venv","__pycache__",".pytest_cache",".mypy_cache",".expo",".next","build","dist","ios","android",".idea",".vscode"}
SKIP_EXT  = {".png",".jpg",".jpeg",".webp",".gif",".ico",".pdf",".svg",".mp4",".mov",".zip",".gz",".tar",".bin",".lock",".xcworkspace",".xcodeproj"}

def is_probably_text(path, blocksize=2048):
    try:
        with open(path, "rb") as f:
            chunk = f.read(blocksize)
        chunk.decode("utf-8")
        return True
    except Exception:
        return False

SECRET_PATTERNS = [
    (re.compile(r'(?i)\b(password|pwd|pass|secret|token|api[_-]?key)\s*[:=]\s*\S+'), r'\1=***REDACTED***'),
    (re.compile(r'(?i)\b(database_url|db_url|database_uri|connection_string)\s*[:=]\s*\S+'), r'\1=***REDACTED***'),
]

def redact(text: str) -> str:
    for pat, repl in SECRET_PATTERNS:
        text = pat.sub(repl, text)
    return text

def write_structure():
    out_path = os.path.join(OUT, "STRUCTURE.txt")
    lines = [f"# Repo structure (filtered)\n# Root: {ROOT}\n"]
    for dirpath, dirnames, filenames in os.walk(ROOT):
        # prune unwanted dirs in-place
        dirnames[:] = [d for d in dirnames if d not in SKIP_DIRS]
        rel = os.path.relpath(dirpath, ROOT)
        lines.append(rel if rel != "." else ".")
        for fn in filenames:
            p = os.path.join(dirpath, fn)
            lines.append("  " + os.path.relpath(p, ROOT))
    with open(out_path, "w", encoding="utf-8") as f:
        f.write("\n".join(lines))
    return out_path

def dump_dir(src_dir: str, out_file: str):
    with open(out_file, "w", encoding="utf-8") as out:
        out.write(f"# Code dump for {src_dir}\n# Generated: {time.strftime('%Y-%m-%dT%H:%M:%S')}\n\n")
        for dirpath, dirnames, filenames in os.walk(src_dir):
            dirnames[:] = [d for d in dirnames if d not in SKIP_DIRS]
            for fn in filenames:
                p = os.path.join(dirpath, fn)
                _, ext = os.path.splitext(fn)
                if ext.lower() in SKIP_EXT:
                    out.write(f"\n===== FILE (binary skipped): {os.path.relpath(p, ROOT)} =====\n")
                    continue
                if not is_probably_text(p):
                    out.write(f"\n===== FILE (binary skipped): {os.path.relpath(p, ROOT)} =====\n")
                    continue
                try:
                    with open(p, "r", encoding="utf-8") as f:
                        txt = f.read()
                except Exception:
                    out.write(f"\n===== FILE (unreadable skipped): {os.path.relpath(p, ROOT)} =====\n")
                    continue
                txt = redact(txt)
                out.write(f"\n===== FILE: {os.path.relpath(p, ROOT)} =====\n")
                out.write(txt)
                if not txt.endswith("\n"):
                    out.write("\n")

def detect_frontend_roots():
    """Return list of dirs that look like JS apps (package.json present)."""
    hits = []
    for dirpath, dirnames, filenames in os.walk(ROOT):
        dirnames[:] = [d for d in dirnames if d not in SKIP_DIRS]
        if "package.json" in filenames:
            pkg_path = os.path.join(dirpath, "package.json")
            try:
                with open(pkg_path, "r", encoding="utf-8") as f:
                    pkg = json.load(f)
                # flag expo/react-native web projects
                if "expo" in (pkg.get("dependencies") or {}) or pkg.get("name"):
                    hits.append(dirpath)
            except Exception:
                hits.append(dirpath)
    return hits

def main():
    print(f"[i] ROOT: {ROOT}")
    struct = write_structure()
    print(f"[i] wrote {struct}")

    # backend dump if exists
    backend_dir = os.path.join(ROOT, "backend")
    if os.path.isdir(backend_dir):
        out_backend = os.path.join(OUT, "CODE_BACKEND.txt")
        dump_dir(backend_dir, out_backend)
        print(f"[i] wrote {out_backend}")
    else:
        print("[i] backend/ not found under ROOT")

    # try to detect frontend
    fronts = detect_frontend_roots()
    if fronts:
        for i, d in enumerate(fronts, 1):
            outf = os.path.join(OUT, f"CODE_FRONTEND_{i}.txt")
            dump_dir(d, outf)
            print(f"[i] wrote {outf} (from {os.path.relpath(d, ROOT)})")
    else:
        print("[i] no JS app detected (no package.json). if your mobile app is elsewhere, run:  python3 dump_code.py /path/to/root")

    print("[i] DONE. Outputs are in", OUT)

if __name__ == "__main__":
    main()

===== FILE: dump_code.sh =====
#!/usr/bin/env bash
set -euo pipefail

ROOT="${1:-$HOME/baku-reserve}"
OUT_DIR="${2:-code_dump}"

cd "$ROOT"
mkdir -p "$OUT_DIR"

# directories to skip (heavy or generated)
PRUNE=(.git node_modules .venv __pycache__ .pytest_cache .mypy_cache .expo .next build dist ios android .idea .vscode)

# build find prune expression
build_prune() {
  local arr=("$@")
  local expr=()
  for d in "${arr[@]}"; do expr+=( -name "$d" -o ); done
  # drop trailing -o
  unset 'expr[${#expr[@]}]'
  printf '%s\0' "${expr[@]}"
}

# write repo structure (filtered)
STRUCT="$OUT_DIR/STRUCTURE.txt"
: > "$STRUCT"
printf "# Repo structure (filtered)\n# Root: %s\n\n" "$ROOT" >> "$STRUCT"
# shellcheck disable=SC2046
find . -type d \( $(build_prune "${PRUNE[@]}") \) -prune -o -print >> "$STRUCT"

dump_dir() {
  local dir="$1"
  local out="$2"

  : > "$out"
  printf "# Code dump for %s\n# Generated: %s\n\n" "$dir" "$(date -Iseconds)" >> "$out"

  # iterate files (skip common binaries)
  # shellcheck disable=SC2046
  while IFS= read -r -d '' f; do
    # skip binary-ish files defensively
    if ! grep -Iq . "$f"; then
      printf "\n===== FILE (binary skipped): %s =====\n" "$f" >> "$out"
      continue
    fi

    printf "\n===== FILE: %s =====\n" "$f" >> "$out"

    # naive redaction of obvious secrets in dumps (doesn't touch your real files)
    sed -E \
      -e 's/([Pp]assword|PWD|PASS|SECRET|Token|TOKEN|API[_-]?KEY|ApiKey|apiKey)\s*[:=]\s*\S+/\\1=***REDACTED***/g' \
      -e 's/(DATABASE_URL|DB_URL|DATABASE_URI|CONNECTION_STRING)\s*[:=]\s*\S+/\\1=***REDACTED***/g' \
      "$f" >> "$out"
    printf "\n" >> "$out"
  done < <(
    find "$dir" \
      -type d \( $(build_prune "${PRUNE[@]}") \) -prune -o \
      -type f ! -name "*.png" ! -name "*.jpg" ! -name "*.jpeg" ! -name "*.webp" ! -name "*.gif" ! -name "*.ico" ! -name "*.pdf" ! -name "*.svg" ! -name "*.mp4" ! -name "*.mov" \
      -print0
  )
}

# dump backend if present
[[ -d "$ROOT/backend"  ]] && dump_dir "$ROOT/backend"  "$OUT_DIR/CODE_BACKEND.txt"
# dump frontend if present
[[ -d "$ROOT/frontend" ]] && dump_dir "$ROOT/frontend" "$OUT_DIR/CODE_FRONTEND.txt"

echo "DONE. Files created in $OUT_DIR:"
ls -lh "$OUT_DIR"
