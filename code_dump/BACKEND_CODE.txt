# Curated code dump
# Generated: 2025-10-23T14:29:00-05:00

===== FILE: backend/app/__init__.py =====

===== FILE: backend/app/availability.py =====
from datetime import datetime, time, timedelta, date
from typing import Any, Dict, List

RES_DURATION = timedelta(minutes=90)
INTERVAL = timedelta(minutes=30)
OPEN = time(10, 0)
CLOSE = time(23, 0)

def _overlaps(a_start: datetime, a_end: datetime, b_start: datetime, b_end: datetime) -> bool:
    return not (a_end <= b_start or a_start >= b_end)

def _iso_parse(s: str) -> datetime:
    return datetime.fromisoformat(s)

def availability_for_day(restaurant: Any, party_size: int, day: date, db) -> Dict[str, Any]:
    """
    Returns: {"slots":[{"start":iso,"end":iso,"available_table_ids":[...],"count":N}, ...]}
    Only considers reservations with status == "booked".
    """
    rid = str(restaurant.get("id"))

    # Tables that fit the party
    tables: List[Dict[str, Any]] = []
    for area in (restaurant.get("areas") or []):
        for t in (area.get("tables") or []):
            cap = int(t.get("capacity", 2) or 2)
            if cap >= party_size:
                tables.append(t)

    # Existing booked reservations for that date, same restaurant
    todays = []
    for r in db.reservations.values():
        if str(r.get("restaurant_id")) != rid:
            continue
        if r.get("status", "booked") != "booked":
            continue
        try:
            rs = _iso_parse(str(r["start"]))
            re = _iso_parse(str(r["end"]))
        except Exception:
            continue
        if rs.date() == day:
            todays.append({"table_id": str(r.get("table_id")), "start": rs, "end": re})

    slots = []
    cur = datetime.combine(day, OPEN)
    last_start = datetime.combine(day, CLOSE) - RES_DURATION

    while cur <= last_start:
        slot_end = cur + RES_DURATION
        free_ids: List[str] = []
        for t in tables:
            tid = str(t.get("id"))
            taken = any(
                (rt["table_id"] == tid) and _overlaps(cur, slot_end, rt["start"], rt["end"])
                for rt in todays
            )
            if not taken:
                free_ids.append(tid)

        slots.append({
            "start": cur.isoformat(timespec="seconds"),
            "end": slot_end.isoformat(timespec="seconds"),
            "available_table_ids": free_ids,
            "count": len(free_ids),
        })
        cur += INTERVAL

    return {"slots": slots}

===== FILE: backend/app/config.py =====
import os
from pathlib import Path

# App version
APP_VERSION = "0.1.1"

# Base dir (this file's folder is backend/app/)
BASE_DIR = Path(__file__).resolve().parent

# Where to persist data (reservations.json). Can be overridden with env:
#   DATA_DIR="/some/dir" uvicorn app.main:app --reload ...
DATA_DIR = Path(os.environ.get("DATA_DIR", str(BASE_DIR / "data")))
DATA_DIR.mkdir(parents=True, exist_ok=True)

# CORS: comma-separated list of origins. Default "*" (allow all).
# Example: ALLOW_ORIGINS="http://localhost:8081,http://192.168.0.148:19000"
_allow = os.environ.get("ALLOW_ORIGINS", "*")
ALLOW_ORIGINS = [o.strip() for o in _allow.split(",") if o.strip()] or ["*"]

===== FILE: backend/app/main.py =====
from fastapi import FastAPI, HTTPException, Query
from uuid import UUID
from typing import Optional, Any, Dict
from datetime import date, datetime

from .schemas import RestaurantListItem
from .models import ReservationCreate, Reservation

from .storage import DB
from .utils import add_cors
from .availability import availability_for_day

app = FastAPI(title="Baku Reserve API", version="0.1.0")
add_cors(app)

@app.get("/health")
def health():
    return {"ok": True, "service": "baku-reserve", "version": "0.1.0"}

# ---------- helpers ----------
def get_attr(o: Any, key: str, default=None):
    if isinstance(o, dict):
        return o.get(key, default)
    return getattr(o, key, default)

def restaurant_to_list_item(r: Any) -> Dict[str, Any]:
    return {
        "id": str(get_attr(r, "id")),
        "name": get_attr(r, "name"),
        "cuisine": list(get_attr(r, "cuisine", []) or []),
        "city": get_attr(r, "city"),
        "cover_photo": (get_attr(r, "cover_photo") or (get_attr(r, "photos", []) or [None])[0]),
    }

def restaurant_to_detail(r: Any) -> Dict[str, Any]:
    areas = []
    for a in (get_attr(r, "areas", []) or []):
        tables = []
        for t in (get_attr(a, "tables", []) or []):
            tables.append({
                "id": str(get_attr(t, "id")),
                "name": get_attr(t, "name") or f"Table {str(get_attr(t, 'id'))[:6]}",
                "capacity": int(get_attr(t, "capacity", 2) or 2),
            })
        areas.append({
            "id": str(get_attr(a, "id")),
            "name": get_attr(a, "name") or "Area",
            "tables": tables,
        })
    return {
        "id": str(get_attr(r, "id")),
        "name": get_attr(r, "name"),
        "cuisine": list(get_attr(r, "cuisine", []) or []),
        "city": get_attr(r, "city"),
        "address": get_attr(r, "address") or "",
        "phone": get_attr(r, "phone") or "",
        "photos": list(get_attr(r, "photos", []) or []),
        "areas": areas,
    }

def rec_to_reservation(rec: Dict[str, Any]) -> Reservation:
    return Reservation(
        id=str(rec["id"]),
        restaurant_id=str(rec["restaurant_id"]),
        table_id=str(rec.get("table_id")) if rec.get("table_id") else None,
        party_size=int(rec["party_size"]),
        start=datetime.fromisoformat(str(rec["start"])) if isinstance(rec["start"], str) else rec["start"],
        end=datetime.fromisoformat(str(rec["end"])) if isinstance(rec["end"], str) else rec["end"],
        guest_name=str(rec.get("guest_name", "")),
        guest_phone=str(rec.get("guest_phone", "")) if rec.get("guest_phone") else None,
        status=str(rec.get("status", "booked")),
    )

# ---------- root redirect to docs ----------
@app.get("/", include_in_schema=False)
def root_redirect():
    # Redirect to docs for convenience when you hit the base URL in a browser.
    return {"detail": "See /docs"}, 307

# ---------- endpoints ----------
@app.get("/restaurants", response_model=list[RestaurantListItem])
def list_restaurants(q: Optional[str] = None):
    items = DB.list_restaurants(q)
    return [restaurant_to_list_item(r) for r in items]

@app.get("/restaurants/{rid}")
def get_restaurant(rid: UUID):
    r = DB.get_restaurant(str(rid))
    if not r:
        raise HTTPException(404, "Restaurant not found")
    return restaurant_to_detail(r)

@app.get("/restaurants/{rid}/floorplan")
def get_floorplan(rid: UUID):
    r = DB.get_restaurant(str(rid))
    if not r:
        raise HTTPException(404, "Restaurant not found")
    canvas = {"width": 1000, "height": 1000}
    areas = []
    for a in (get_attr(r, "areas", []) or []):
        tables = []
        for t in (get_attr(a, "tables", []) or []):
            tables.append({
                "id": str(get_attr(t, "id")),
                "name": get_attr(t, "name"),
                "capacity": int(get_attr(t, "capacity", 2) or 2),
                "position": get_attr(t, "position"),
                "shape": get_attr(t, "shape"),
            })
        areas.append({"id": str(get_attr(a, "id")), "name": get_attr(a, "name"), "tables": tables})
    return {"canvas": canvas, "areas": areas}

@app.post("/reservations", response_model=Reservation, status_code=201)
def create_reservation(payload: ReservationCreate):
    try:
        res = DB.create_reservation(payload)
        return res
    except HTTPException as e:
        raise e
    except ValueError as e:
        raise HTTPException(409, str(e))

@app.post("/reservations/{resid}/cancel", response_model=Reservation)
def soft_cancel_reservation(resid: UUID):
    rec = DB.set_status(str(resid), "cancelled")
    if not rec:
        raise HTTPException(404, "Reservation not found")
    return rec_to_reservation(rec)

@app.post("/reservations/{resid}/confirm", response_model=Reservation)
def confirm_reservation(resid: UUID):
    rec = DB.set_status(str(resid), "booked")
    if not rec:
        raise HTTPException(404, "Reservation not found")
    return rec_to_reservation(rec)

@app.delete("/reservations/{resid}", response_model=Reservation)
def hard_delete_reservation(resid: UUID):
    r = DB.cancel_reservation(str(resid))
    if not r:
        raise HTTPException(404, "Reservation not found")
    return rec_to_reservation(r)

@app.get("/restaurants/{rid}/availability")
def availability(rid: UUID, date_: date = Query(..., alias="date"), party_size: int = 2):
    r = DB.get_restaurant(str(rid))
    if not r:
        raise HTTPException(404, "Restaurant not found")
    return availability_for_day(r, party_size, date_, DB)

@app.get("/reservations")
def list_reservations():
    return DB.list_reservations()

===== FILE: backend/app/models.py =====
from __future__ import annotations
from pydantic import BaseModel, Field, field_validator
from typing import List, Optional, Literal
from datetime import datetime

# --- Tables & floorplan (string IDs so our demo IDs work) ---
class Table(BaseModel):
    id: str
    name: Optional[str] = None
    capacity: int = 2

class Area(BaseModel):
    id: str
    name: Optional[str] = None
    tables: List[Table] = Field(default_factory=list)

# --- Restaurant list/detail ---
class RestaurantListItem(BaseModel):
    id: str
    name: str
    cuisine: List[str] = Field(default_factory=list)
    city: str
    cover_photo: Optional[str] = None

class Restaurant(BaseModel):
    id: str
    name: str
    cuisine: List[str] = Field(default_factory=list)
    city: str = "Baku"
    address: Optional[str] = None
    phone: Optional[str] = None
    photos: List[str] = Field(default_factory=list)
    areas: List[Area] = Field(default_factory=list)

# --- Reservations ---
class ReservationCreate(BaseModel):
    restaurant_id: str
    party_size: int
    start: datetime
    end: datetime
    guest_name: str
    guest_phone: Optional[str] = None
    table_id: Optional[str] = None

    @field_validator("party_size")
    @classmethod
    def _party_positive(cls, v: int) -> int:
        if v < 1:
            raise ValueError("party_size must be >= 1")
        return v

    @field_validator("end")
    @classmethod
    def _end_after_start(cls, v: datetime, info):
        start = info.data.get("start")
        if isinstance(start, datetime) and v <= start:
            raise ValueError("end must be after start")
        return v

class Reservation(BaseModel):
    id: str
    restaurant_id: str
    party_size: int
    start: datetime
    end: datetime
    guest_name: str
    guest_phone: Optional[str] = None
    table_id: Optional[str] = None
    status: Literal["booked", "cancelled"] = "booked"

===== FILE: backend/app/schemas.py =====
from pydantic import BaseModel, Field, field_validator
from typing import List, Optional, Literal, Tuple
from datetime import datetime
from uuid import UUID, uuid4

class Table(BaseModel):
    id: UUID = Field(default_factory=uuid4)
    name: str
    capacity: int
    position: Tuple[int, int] | None = None
    shape: Literal["circle", "rect"] = "circle"

class Area(BaseModel):
    id: UUID = Field(default_factory=uuid4)
    name: str
    tables: List[Table] = Field(default_factory=list)

class Restaurant(BaseModel):
    id: UUID = Field(default_factory=uuid4)
    name: str
    cuisine: List[str] = Field(default_factory=list)
    city: str = "Baku"
    address: Optional[str] = None
    phone: Optional[str] = None
    photos: List[str] = Field(default_factory=list)
    areas: List[Area] = Field(default_factory=list)

class RestaurantListItem(BaseModel):
    id: UUID
    name: str
    cuisine: List[str]
    city: str
    cover_photo: Optional[str] = None

class ReservationCreate(BaseModel):
    restaurant_id: UUID
    party_size: int
    start: datetime
    end: datetime
    guest_name: str
    guest_phone: Optional[str] = None
    table_id: Optional[UUID] = None

    @field_validator("party_size")
    @classmethod
    def _party_positive(cls, v: int) -> int:
        if v < 1:
            raise ValueError("party_size must be >= 1")
        return v

    @field_validator("end")
    @classmethod
    def _end_after_start(cls, v: datetime, info):
        start = info.data.get("start")
        if isinstance(start, datetime) and v <= start:
            raise ValueError("end must be after start")
        return v

class Reservation(BaseModel):
    id: UUID = Field(default_factory=uuid4)
    restaurant_id: UUID
    party_size: int
    start: datetime
    end: datetime
    guest_name: str
    guest_phone: Optional[str] = None
    table_id: Optional[UUID] = None
    status: Literal["booked", "cancelled"] = "booked"

===== FILE: backend/app/seed.py =====
from .schemas import Restaurant, Area, Table
from .storage import DB

def seed():
    if DB.restaurants:
        return

    def t(name, cap, x, y):
        return Table(name=name, capacity=cap, position=(x,y))

    sahil = Restaurant(
        name="SAHiL Bar & Restaurant",
        cuisine=["Azerbaijani","Seafood"],
        city="Baku",
        address="Neftchilar Ave, Seaside Boulevard",
        phone="+994 12 000 0000",
        photos=["https://picsum.photos/seed/sahil/800/500"],
        areas=[
            Area(name="Main Hall", tables=[t("T1",4,200,300), t("T2",2,350,320), t("T3",4,480,310)]),
            Area(name="Terrace", tables=[t("W1",2,700,220), t("W2",4,820,260)]),
        ]
    )

    gunaydin = Restaurant(
        name="Günaydın Steakhouse (Bulvar)",
        cuisine=["Steakhouse","Turkish"],
        city="Baku",
        address="Bulvar Mall",
        phone="+994 12 111 1111",
        photos=["https://picsum.photos/seed/gunaydin/800/500"],
        areas=[
            Area(name="Steak Hall", tables=[t("S1",2,180,600), t("S2",4,260,640), t("S3",6,360,620)]),
            Area(name="Window", tables=[t("W1",2,700,650), t("W2",2,780,660)]),
        ]
    )

    mari = Restaurant(
        name="Mari Vanna",
        cuisine=["Eastern European","Russian"],
        city="Baku",
        address="Old City",
        phone="+994 12 222 2222",
        photos=["https://picsum.photos/seed/marivanna/800/500"],
        areas=[
            Area(name="Parlor", tables=[t("P1",2,240,200), t("P2",4,340,240)]),
            Area(name="Garden", tables=[t("G1",2,720,300), t("G2",4,820,320)]),
        ]
    )

    for r in (sahil, gunaydin, mari):
        DB.add_restaurant(r)

===== FILE: backend/app/settings.py =====
from __future__ import annotations
from pydantic_settings import BaseSettings, SettingsConfigDict
from pydantic import AnyHttpUrl, field_validator
from typing import List, Optional
from pathlib import Path

class Settings(BaseSettings):
    model_config = SettingsConfigDict(env_file=".env", env_file_encoding="utf-8", extra="ignore")

    # whether to expose the debug config endpoint
    DEBUG: bool = True

    # persistence directory (defaults to app/data)
    DATA_DIR: Optional[Path] = None

    # CORS allow origins (comma-separated). Default "*" for dev.
    CORS_ALLOW_ORIGINS: str = "*"

    @property
    def allow_origins(self) -> List[str]:
        s = (self.CORS_ALLOW_ORIGINS or "").strip()
        if s == "" or s == "*":
            return ["*"]
        return [part.strip() for part in s.split(",") if part.strip()]

    @property
    def data_dir(self) -> Path:
        # default to <this file>/data when not set
        if self.DATA_DIR:
            return Path(self.DATA_DIR).expanduser().resolve()
        return (Path(__file__).resolve().parent / "data").resolve()

settings = Settings()
# make sure directory exists when imported
settings.data_dir.mkdir(parents=True, exist_ok=True)

===== FILE: backend/app/storage.py =====
from __future__ import annotations

import json
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional
from uuid import uuid4

from fastapi import HTTPException
from .models import Reservation, ReservationCreate

DATA_DIR = Path(__file__).resolve().parent / "data"
DATA_DIR.mkdir(parents=True, exist_ok=True)
RES_PATH = DATA_DIR / "reservations.json"

def _iso(dt: datetime) -> str:
    return dt.isoformat(timespec="seconds")

def _parse_iso(s: str) -> datetime:
    return datetime.fromisoformat(s)

class Database:
    """
    Demo DB:
      - Restaurants seeded here with stable ids.
      - Reservations persist to app/data/reservations.json
    """
    def __init__(self) -> None:
        # --- restaurants ---
        self.restaurants: Dict[str, Dict[str, Any]] = {
            "fc34a984-0b39-4f0a-afa2-5b677c61f044": {
                "id": "fc34a984-0b39-4f0a-afa2-5b677c61f044",
                "name": "SAHiL Bar & Restaurant",
                "cuisine": ["Azerbaijani", "Seafood"],
                "city": "Baku",
                "address": "Seaside Boulevard, Baku",
                "phone": "+994 12 000 00 00",
                "photos": ["https://picsum.photos/seed/sahil/800/500"],
                "cover_photo": "https://picsum.photos/seed/sahil/800/500",
                "areas": [
                    {
                        "id": "a-sahil-main",
                        "name": "Main Hall",
                        "tables": [
                            {"id": "e5c360cf-31df-4276-841e-8cd720b5942c", "name": "T1", "capacity": 2},
                            {"id": "cc67ebfe-9fad-427f-87c1-d591304fcce5", "name": "T2", "capacity": 2},
                            {"id": "40ec9ced-a11f-4009-899c-7b2d4216dea3", "name": "T3", "capacity": 4},
                            {"id": "b79563ac-0f21-4b3a-9b50-c2b6ba2a3b18", "name": "T4", "capacity": 4},
                            {"id": "9e5f3998-67d7-4a81-a816-109aec7bdeec", "name": "T5", "capacity": 6},
                        ],
                    }
                ],
            },
            "e43356ca-448a-4257-a76c-716b9f13937b": {
                "id": "e43356ca-448a-4257-a76c-716b9f13937b",
                "name": "Günaydın Steakhouse (Bulvar)",
                "cuisine": ["Steakhouse", "Turkish"],
                "city": "Baku",
                "address": "Bulvar Mall, Baku",
                "phone": "+994 12 111 11 11",
                "photos": ["https://picsum.photos/seed/gunaydin/800/500"],
                "cover_photo": "https://picsum.photos/seed/gunaydin/800/500",
                "areas": [
                    {
                        "id": "a-gunaydin-main",
                        "name": "Main Hall",
                        "tables": [
                            {"id": "f1e1b8e1-aaaa-4b11-9aaa-111111111111", "name": "A1", "capacity": 2},
                            {"id": "f1e1b8e1-bbbb-4b22-9bbb-222222222222", "name": "A2", "capacity": 4},
                            {"id": "f1e1b8e1-cccc-4b33-9ccc-333333333333", "name": "A3", "capacity": 6},
                        ],
                    }
                ],
            },
            "7cb45fee-78d6-46cf-a9fd-a8299e47e4fa": {
                "id": "7cb45fee-78d6-46cf-a9fd-a8299e47e4fa",
                "name": "Mari Vanna",
                "cuisine": ["Eastern European", "Russian"],
                "city": "Baku",
                "address": "Old City, Baku",
                "phone": "+994 12 222 22 22",
                "photos": ["https://picsum.photos/seed/marivanna/800/500"],
                "cover_photo": "https://picsum.photos/seed/marivanna/800/500",
                "areas": [
                    {
                        "id": "a-marivanna-main",
                        "name": "Main Hall",
                        "tables": [
                            {"id": "mvt-1", "name": "M1", "capacity": 2},
                            {"id": "mvt-2", "name": "M2", "capacity": 4},
                            {"id": "mvt-3", "name": "M3", "capacity": 6},
                        ],
                    }
                ],
            },
        }

        self.reservations: Dict[str, Dict[str, Any]] = {}
        self._load()

    # -------- helpers --------
    def _tables_for_restaurant(self, rid: str) -> List[Dict[str, Any]]:
        r = self.restaurants.get(rid)
        tables: List[Dict[str, Any]] = []
        if not r:
            return tables
        for area in (r.get("areas") or []):
            for t in (area.get("tables") or []):
                tables.append(t)
        return tables

    def _table_lookup(self, rid: str) -> Dict[str, Dict[str, Any]]:
        return {str(t["id"]): t for t in self._tables_for_restaurant(rid)}

    @staticmethod
    def _overlap(a_start: datetime, a_end: datetime, b_start: datetime, b_end: datetime) -> bool:
        return not (a_end <= b_start or b_end <= a_start)

    # -------- restaurants --------
    def list_restaurants(self, q: Optional[str] = None) -> List[Dict[str, Any]]:
        items = list(self.restaurants.values())
        if q:
            qlow = q.lower()
            items = [
                r for r in items
                if qlow in r["name"].lower()
                or any(qlow in c.lower() for c in r.get("cuisine", []))
                or qlow in r.get("city", "").lower()
            ]
        return [
            {
                "id": r["id"],
                "name": r["name"],
                "cuisine": r["cuisine"],
                "city": r["city"],
                "cover_photo": r.get("cover_photo") or (r["photos"][0] if r.get("photos") else ""),
            }
            for r in items
        ]

    def get_restaurant(self, rid: str) -> Optional[Dict[str, Any]]:
        return self.restaurants.get(str(rid))

    # -------- reservations --------
    def list_reservations(self) -> List[Dict[str, Any]]:
        return list(self.reservations.values())

    def create_reservation(self, payload: ReservationCreate) -> Reservation:
        rid = str(payload.restaurant_id)

        if payload.party_size < 1:
            raise HTTPException(status_code=422, detail="party_size must be >= 1")
        start = payload.start if isinstance(payload.start, datetime) else _parse_iso(str(payload.start))
        end = payload.end if isinstance(payload.end, datetime) else _parse_iso(str(payload.end))
        if end <= start:
            raise HTTPException(status_code=422, detail="end must be after start")

        if rid not in self.restaurants:
            raise HTTPException(status_code=404, detail="Restaurant not found")

        tables_by_id = self._table_lookup(rid)
        # resolve table
        if payload.table_id:
            tid = str(payload.table_id)
            if tid not in tables_by_id:
                raise HTTPException(status_code=422, detail="table_id does not belong to restaurant")
            if tables_by_id[tid].get("capacity", 1) < payload.party_size:
                raise HTTPException(status_code=422, detail="party_size exceeds table capacity")
            table_id = tid
        else:
            table_id = None
            candidates = sorted(tables_by_id.values(), key=lambda t: t.get("capacity", 2))
            for t in candidates:
                if t.get("capacity", 2) >= payload.party_size:
                    table_id = str(t["id"])
                    break
            if not table_id and candidates:
                table_id = str(candidates[-1]["id"])

        # conflict check (booked only)
        for r in self.reservations.values():
            if str(r["restaurant_id"]) != rid:
                continue
            if r.get("status", "booked") != "booked":
                continue
            if table_id and r.get("table_id") and str(r["table_id"]) != table_id:
                continue
            rs = _parse_iso(r["start"]) if isinstance(r["start"], str) else r["start"]
            re = _parse_iso(r["end"]) if isinstance(r["end"], str) else r["end"]
            if self._overlap(start, end, rs, re):
                raise HTTPException(status_code=409, detail="Selected table/time is already booked")

        new_id = str(uuid4())
        rec = {
            "id": new_id,
            "restaurant_id": rid,
            "table_id": table_id,
            "party_size": payload.party_size,
            "start": _iso(start),
            "end": _iso(end),
            "guest_name": payload.guest_name,
            "guest_phone": payload.guest_phone or "",
            "status": "booked",
        }
        self.reservations[new_id] = rec
        self._save()

        return Reservation(**{**rec, "start": start, "end": end})

    def set_status(self, resid: str, status: str) -> Optional[Dict[str, Any]]:
        if resid not in self.reservations:
            return None
        if status not in ("booked", "cancelled"):
            raise HTTPException(status_code=422, detail="invalid status")
        self.reservations[resid]["status"] = status
        self._save()
        return self.reservations[resid]

    def cancel_reservation(self, resid: str) -> Optional[Dict[str, Any]]:
        # Hard delete (used by existing DELETE route)
        out = self.reservations.pop(str(resid), None)
        if out is not None:
            self._save()
        return out

    # -------- persistence --------
    def _save(self) -> None:
        data = {
            "reservations": [
                {
                    **{k: v for k, v in r.items() if k not in ("start", "end")},
                    "start": r["start"] if isinstance(r["start"], str) else _iso(r["start"]),
                    "end": r["end"] if isinstance(r["end"], str) else _iso(r["end"]),
                }
                for r in self.reservations.values()
            ]
        }
        RES_PATH.write_text(json.dumps(data, ensure_ascii=False, indent=2))

    def _load(self) -> None:
        if not RES_PATH.exists():
            return
        try:
            raw = json.loads(RES_PATH.read_text() or "{}")
        except Exception:
            self.reservations = {}
            return

        cleaned: Dict[str, Dict[str, Any]] = {}
        for r in raw.get("reservations", []):
            try:
                rid = str(r.get("id") or uuid4())
                rest_id = str(r["restaurant_id"])
                start = _parse_iso(str(r["start"]))
                end = _parse_iso(str(r["end"]))
                if end <= start:
                    continue
                party = int(r["party_size"])
                if party < 1:
                    continue
                status = r.get("status", "booked")
                if status not in ("booked", "cancelled"):
                    status = "booked"
                cleaned[rid] = {
                    "id": rid,
                    "restaurant_id": rest_id,
                    "table_id": r.get("table_id"),
                    "party_size": party,
                    "start": _iso(start),
                    "end": _iso(end),
                    "guest_name": str(r.get("guest_name", "")),
                    "guest_phone": str(r.get("guest_phone", "")),
                    "status": status,
                }
            except Exception:
                continue
        self.reservations = cleaned

# Single instance
DB = Database()

===== FILE: backend/app/utils.py =====
from fastapi.middleware.cors import CORSMiddleware
from .settings import settings

def add_cors(app):
    app.add_middleware(
        CORSMiddleware,
        allow_origins=settings.allow_origins,
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
        expose_headers=["*"],
    )

===== FILE: backend/backend_smoketest.sh =====
#!/usr/bin/env bash
set -u

### CONFIG #####################################################################
BASE="${BASE:-http://192.168.0.148:8000}"
TEST_DATE="${TEST_DATE:-2025-10-23}"   # change if you want to test another day
NAME_PREFIX="SMOKE_$(date +%s)_"
JQ_BIN="${JQ_BIN:-jq}"

### REQUIREMENTS ###############################################################
command -v curl >/dev/null || { echo "[FATAL] curl required"; exit 1; }
command -v ${JQ_BIN} >/dev/null || { echo "[FATAL] jq required"; exit 1; }

### HARNESS ####################################################################
fail=0; pass=0
log()   { printf "%b\n" "$*"; }
ok()    { pass=$((pass+1)); log "✅  $*"; }
bad()   { fail=$((fail+1)); log "❌  $*"; }
sep()   { printf "\n===== %s =====\n" "$*"; }

# curl wrapper that captures HTTP code and body safely
req() {
  local method="$1"; shift
  local url="$1"; shift
  local data="${1:-}"
  local tmp_b="$(mktemp)"; local code

  if [[ -z "$data" ]]; then
    code=$(curl -sS -o "$tmp_b" -w "%{http_code}" -X "$method" "$url" -H "Accept: application/json")
  else
    code=$(curl -sS -o "$tmp_b" -w "%{http_code}" -X "$method" "$url" \
      -H "Accept: application/json" -H "Content-Type: application/json" --data "$data")
  fi
  echo "$code $tmp_b"
}

expect_code() {
  local want="$1"; local got="$2"
  if [[ "$want" == "$got" ]]; then return 0; fi
  # allow ranges like 4xx
  if [[ "$want" =~ x$ ]]; then
    local pfx="${want%x}"
    [[ "${got:0:1}" == "$pfx" ]] && return 0
  fi
  return 1
}

# delete all reservations whose guest_name starts with NAME_PREFIX
cleanup_smoke_reservations() {
  local code tmp out
  read -r code tmp < <(req GET "$BASE/reservations")
  out="$(cat "$tmp")"
  if ! expect_code 200 "$code"; then bad "GET /reservations ($code)"; return; fi
  local ids
  ids=$(echo "$out" | ${JQ_BIN} -r --arg pfx "$NAME_PREFIX" '.[] | select(.guest_name|startswith($pfx)) | .id')
  if [[ -z "$ids" ]]; then ok "No lingering $NAME_PREFIX reservations"; return; fi
  while IFS= read -r rid; do
    [[ -z "$rid" ]] && continue
    read -r code tmp < <(req DELETE "$BASE/reservations/$rid")
    if expect_code 200 "$code"; then ok "DELETE /reservations/$rid"; else bad "DELETE /reservations/$rid ($code)"; fi
  done <<< "$ids"
}

### DISCOVER DATA ##############################################################
sep "A0. Discover restaurants"
read -r code tmp < <(req GET "$BASE/restaurants")
if ! expect_code 200 "$code"; then bad "GET /restaurants ($code)"; exit 1; fi
out="$(cat "$tmp")"

# Prefer SAHiL; else pick first
RID=$(echo "$out" | ${JQ_BIN} -r '
  (map(select(.name=="SAHiL Bar & Restaurant"))[0].id) // (.[0].id)
')
if [[ -z "$RID" || "$RID" == "null" ]]; then bad "No restaurant found"; exit 1; fi
ok "Selected restaurant: $RID"

read -r code tmp < <(req GET "$BASE/restaurants/$RID")
if ! expect_code 200 "$code"; then bad "GET /restaurants/$RID ($code)"; exit 1; fi
RJSON="$(cat "$tmp")"

# classify tables by capacity
T2_IDS=$(echo "$RJSON" | ${JQ_BIN} -r '.areas[].tables[] | select(.capacity==2) | .id')
T4_IDS=$(echo "$RJSON" | ${JQ_BIN} -r '.areas[].tables[] | select(.capacity==4) | .id')
T6_IDS=$(echo "$RJSON" | ${JQ_BIN} -r '.areas[].tables[] | select(.capacity>=6) | .id')

T2_ONE=$(echo "$T2_IDS" | head -n1)
T4_ONE=$(echo "$T4_IDS" | head -n1)
T6_ONE=$(echo "$T6_IDS" | head -n1)

[[ -n "$T2_ONE" ]] && ok "Found 2-top: $T2_ONE" || bad "No 2-top table"
[[ -n "$T4_ONE" ]] && ok "Found 4-top: $T4_ONE" || bad "No 4-top table"
[[ -n "$T6_ONE" ]] && ok "Found 6-top+: $T6_ONE" || bad "No 6-top+ table"

sep "A1. Baseline availability"
read -r code tmp < <(req GET "$BASE/restaurants/$RID/availability?date=$TEST_DATE&party_size=2")
if expect_code 200 "$code"; then
  AJSON="$(cat "$tmp")"
  SLOTS_COUNT=$(echo "$AJSON" | ${JQ_BIN} '.slots | length')
  if [[ "$SLOTS_COUNT" -gt 0 ]]; then ok "Availability has $SLOTS_COUNT slots"; else bad "No slots returned"; fi
else
  bad "GET availability ($code)"
fi

### CLEAN START ###############################################################
sep "A2. Pre-run cleanup"
cleanup_smoke_reservations

### HELPERS FOR BOOKING #######################################################
book() {
  # args: table_id start end party_size name
  local tid="$1" s="$2" e="$3" ps="$4" name="$5"
  local payload
  payload=$(cat <<JSON
{
  "restaurant_id":"$RID",
  "party_size": $ps,
  "start":"$s",
  "end":"$e",
  "guest_name":"$name",
  "guest_phone":"+1555555",
  "table_id":"$tid"
}
JSON
)
  read -r code tmp < <(req POST "$BASE/reservations" "$payload")
  echo "$code $(cat "$tmp")"
}

first_slot_for_party() {
  local ps="$1"
  read -r code tmp < <(req GET "$BASE/restaurants/$RID/availability?date=$TEST_DATE&party_size=$ps")
  if ! expect_code 200 "$code"; then echo ""; return; fi
  cat "$tmp" | ${JQ_BIN} -r '.slots[0] | [.start,.end] | @tsv'
}

first_slot_and_table_for_party() {
  local ps="$1"
  read -r code tmp < <(req GET "$BASE/restaurants/$RID/availability?date=$TEST_DATE&party_size=$ps")
  if ! expect_code 200 "$code"; then echo ""; return; fi
  cat "$tmp" | ${JQ_BIN} -r '.slots[0] | "\(.start)\t\(.end)\t\(.available_table_ids[0])"'
}

reappears_in_slot() {
  # args: start table_id party_size
  local s="$1" tid="$2" ps="$3"
  read -r code tmp < <(req GET "$BASE/restaurants/$RID/availability?date=$TEST_DATE&party_size=$ps")
  if ! expect_code 200 "$code"; then echo "ERR"; return; fi
  cat "$tmp" | ${JQ_BIN} -r --arg s "$s" --arg tid "$tid" '
    .slots[] | select(.start==$s) | (.available_table_ids | index($tid)) | if .==null then "NO" else "YES" end
  '
}

### B. VALID RESERVATION CYCLE #################################################
sep "B. Valid cycle: create -> list -> availability -> delete"
IFS=$'\t' read -r S1 E1 TID1 < <(first_slot_and_table_for_party 2)
if [[ -z "${S1:-}" || -z "${TID1:-}" ]]; then bad "Could not pick first slot/table"; else ok "Picked slot $S1..$E1 table $TID1"; fi

read -r code body < <(book "$TID1" "$S1" "$E1" 2 "${NAME_PREFIX}CYCLE1")
if expect_code 201 "$code"; then ok "POST /reservations (created)"; else bad "POST /reservations ($code): $body"; fi

# list
read -r code tmp < <(req GET "$BASE/reservations")
if expect_code 200 "$code"; then
  RID1=$(cat "$tmp" | ${JQ_BIN} -r --arg name "${NAME_PREFIX}CYCLE1" '.[] | select(.guest_name==$name) | .id' | head -n1)
  [[ -n "$RID1" ]] && ok "Reservation listed: $RID1" || bad "Reservation not in list"
else
  bad "GET /reservations ($code)"
fi

# ensure table removed from that slot
R=$(reappears_in_slot "$S1" "$TID1" 2)
if [[ "$R" == "NO" ]]; then ok "Booked table removed from availability"; else bad "Booked table still appears in availability"; fi

# delete it
if [[ -n "${RID1:-}" ]]; then
  read -r code tmp < <(req DELETE "$BASE/reservations/$RID1")
  expect_code 200 "$code" && ok "DELETE /reservations/$RID1" || bad "DELETE /reservations/$RID1 ($code)"
fi

### C. OVERLAP VALIDATION (same table, same time) ##############################
sep "C. Overlap: identical slot on same table"
IFS=$'\t' read -r S2 E2 TID2 < <(first_slot_and_table_for_party 2)
read -r cA bA < <(book "$TID2" "$S2" "$E2" 2 "${NAME_PREFIX}OVL1")
if expect_code 201 "$cA"; then ok "Initial booking OK"; else bad "Initial booking failed ($cA)"; fi

read -r cB bB < <(book "$TID2" "$S2" "$E2" 2 "${NAME_PREFIX}OVL2")
if expect_code 4x "$cB"; then ok "Double-book rejected ($cB)"; else bad "Double-book NOT rejected ($cB)"; fi

# cleanup
RID_OVL=$(echo "$bA" | ${JQ_BIN} -r '.id // empty')
[[ -n "$RID_OVL" ]] && read -r code tmp < <(req DELETE "$BASE/reservations/$RID_OVL") && expect_code 200 "$code" && ok "Cleaned overlap booking" || true

### D. PARTIAL OVERLAPS ########################################################
sep "D. Partial overlap: consecutive overlapping windows"
# pick two consecutive windows (slots[1] and slots[2]) on same table if possible
read -r code tmp < <(req GET "$BASE/restaurants/$RID/availability?date=$TEST_DATE&party_size=2")
if expect_code 200 "$code"; then
  S10=$(cat "$tmp" | ${JQ_BIN} -r '.slots[1].start')
  E10=$(cat "$tmp" | ${JQ_BIN} -r '.slots[1].end')
  T10=$(cat "$tmp" | ${JQ_BIN} -r '.slots[1].available_table_ids[0]')
  S11=$(cat "$tmp" | ${JQ_BIN} -r '.slots[2].start')
  E11=$(cat "$tmp" | ${JQ_BIN} -r '.slots[2].end')
  T11="$T10"  # try same table to force overlap
  if [[ "$S10" != "null" && -n "$T10" && "$S11" != "null" ]]; then
    read -r c1 b1 < <(book "$T10" "$S10" "$E10" 2 "${NAME_PREFIX}PART1")
    if expect_code 201 "$c1"; then ok "Booked PART1"; else bad "PART1 failed ($c1)"; fi
    read -r c2 b2 < <(book "$T11" "$S11" "$E11" 2 "${NAME_PREFIX}PART2")
    if expect_code 4x "$c2"; then ok "Overlapping PART2 rejected"; else bad "Overlapping PART2 NOT rejected ($c2)"; fi
    # cleanup PART1
    RIDP=$(echo "$b1" | ${JQ_BIN} -r '.id // empty')
    [[ -n "$RIDP" ]] && read -r code tmp < <(req DELETE "$BASE/reservations/$RIDP") && expect_code 200 "$code" && ok "Cleaned PART1" || true
  else
    bad "Could not derive overlapping windows"
  fi
else
  bad "GET availability for partial overlap ($code)"
fi

### E. CAPACITY & PARTY SIZE ###################################################
sep "E1. Capacity: 6 people on 2-top should fail"
# Use a valid window for party_size=6 then force a 2-top table
IFS=$'\t' read -r S6 E6 T6AV < <(first_slot_and_table_for_party 6)
if [[ -z "${S6:-}" ]]; then
  ok "No 6-person slots; capacity rules implicitly hold (skipping forced fail)"
else
  if [[ -n "${T2_ONE:-}" ]]; then
    read -r c b < <(book "$T2_ONE" "$S6" "$E6" 6 "${NAME_PREFIX}CAP_BAD")
    expect_code 4x "$c" && ok "Rejected 6 on 2-top ($c)" || bad "Accepted 6 on 2-top ($c)"
  else
    bad "No 2-top to test capacity rejection"
  fi
fi

sep "E2. Valid 4 on 4-top then 4 on 2-top should fail"
IFS=$'\t' read -r S4 E4 T4AV < <(first_slot_and_table_for_party 4)
if [[ -n "${T4_ONE:-}" && -n "${S4:-}" ]]; then
  read -r c1 b1 < <(book "$T4_ONE" "$S4" "$E4" 4 "${NAME_PREFIX}CAP_GOOD4")
  expect_code 201 "$c1" && ok "Booked 4 on 4-top" || bad "Failed to book 4 on 4-top ($c1)"
  if [[ -n "${T2_ONE:-}" ]]; then
    read -r c2 b2 < <(book "$T2_ONE" "$S4" "$E4" 4 "${NAME_PREFIX}CAP_BAD4")
    expect_code 4x "$c2" && ok "Rejected 4 on 2-top" || bad "Accepted 4 on 2-top ($c2)"
  fi
  # cleanup
  RIDG=$(echo "$b1" | ${JQ_BIN} -r '.id // empty')
  [[ -n "$RIDG" ]] && read -r code tmp < <(req DELETE "$BASE/reservations/$RIDG") && expect_code 200 "$code" && ok "Cleaned 4-on-4 booking" || true
else
  bad "No 4-top or slot to test"
fi

sep "E3. party_size=1 on 2-top should succeed"
IFS=$'\t' read -r S1p E1p T1p < <(first_slot_and_table_for_party 2)
if [[ -n "${S1p:-}" && -n "${T2_ONE:-}" ]]; then
  read -r c b < <(book "$T2_ONE" "$S1p" "$E1p" 1 "${NAME_PREFIX}ONE_OK")
  expect_code 201 "$c" && ok "Booked 1 on 2-top" || bad "Failed 1 on 2-top ($c)"
  RID1p=$(echo "$b" | ${JQ_BIN} -r '.id // empty'); [[ -n "$RID1p" ]] && read -r code tmp < <(req DELETE "$BASE/reservations/$RID1p") && expect_code 200 "$code" && ok "Cleaned 1-on-2 booking" || true
else
  bad "Could not find 2-top to validate party_size=1"
fi

### F. DATE EDGE CASES #########################################################
sep "F. Date edges (past/future/invalid)"
read -r code tmp < <(req GET "$BASE/restaurants/$RID/availability?date=2020-01-01&party_size=2")
expect_code 200 "$code" && ok "Past date handled" || bad "Past date ($code)"

read -r code tmp < <(req GET "$BASE/restaurants/$RID/availability?date=2026-10-23&party_size=2")
expect_code 200 "$code" && ok "Far future date handled" || bad "Future date ($code)"

read -r code tmp < <(req GET "$BASE/restaurants/$RID/availability?party_size=2")
expect_code 4x "$code" && ok "Missing date rejected ($code)" || ok "Missing date allowed ($code) — acceptable per API"

read -r code tmp < <(req GET "$BASE/restaurants/$RID/availability?date=BADDATE&party_size=2")
expect_code 4x "$code" && ok "Invalid date rejected ($code)" || bad "Invalid date NOT rejected ($code)"

### G. INPUT VALIDATION ########################################################
sep "G. Input validation (schema & logic)"
# Missing table_id
payload=$(cat <<JSON
{
  "restaurant_id":"$RID",
  "party_size":2,
  "start":"$S1",
  "end":"$E1",
  "guest_name":"${NAME_PREFIX}NO_TABLE",
  "guest_phone":"+1555000"
}
JSON
)
read -r code tmp < <(req POST "$BASE/reservations" "$payload")
expect_code 4x "$code" && ok "Missing table_id rejected" || bad "Missing table_id accepted ($code)"

# Bad date formats
read -r code tmp < <(req POST "$BASE/reservations" '{
  "restaurant_id":"'"$RID"'",
  "party_size":2,
  "start":"10-23-2025 10:00",
  "end":"10-23-2025 11:30",
  "guest_name":"'"${NAME_PREFIX}BAD_DATE"'",
  "guest_phone":"+1555",
  "table_id":"'"$T2_ONE"'"
}')
expect_code 4x "$code" && ok "Bad date format rejected" || bad "Bad date format accepted ($code)"

# Negative / zero / non-integer party_size
for ps in -1 0 '"two"'; do
  read -r code tmp < <(req POST "$BASE/reservations" '{
    "restaurant_id":"'"$RID"'",
    "party_size":'"$ps"',
    "start":"'"$S1"'",
    "end":"'"$E1"'",
    "guest_name":"'"${NAME_PREFIX}BAD_PS_$ps"'",
    "guest_phone":"+1555",
    "table_id":"'"$T2_ONE"'"
  }')
  expect_code 4x "$code" && ok "party_size='"$ps"' rejected" || bad "party_size='$ps' accepted ($code)"
done

# end == start
read -r code tmp < <(req POST "$BASE/reservations" '{
  "restaurant_id":"'"$RID"'",
  "party_size":2,
  "start":"'"$S1"'",
  "end":"'"$S1"'",
  "guest_name":"'"${NAME_PREFIX}ZERO_DURATION"'",
  "guest_phone":"+1",
  "table_id":"'"$T2_ONE"'"
}')
expect_code 4x "$code" && ok "Zero-duration rejected" || bad "Zero-duration accepted ($code)"

# end < start
read -r code tmp < <(req POST "$BASE/reservations" '{
  "restaurant_id":"'"$RID"'",
  "party_size":2,
  "start":"'"$E1"'",
  "end":"'"$S1"'",
  "guest_name":"'"${NAME_PREFIX}NEG_DURATION"'",
  "guest_phone":"+1",
  "table_id":"'"$T2_ONE"'"
}')
expect_code 4x "$code" && ok "End < Start rejected" || bad "End < Start accepted ($code)"

# Invalid UUIDs / mismatched IDs
read -r code tmp < <(req GET "$BASE/restaurants/NOT-A-UUID")
expect_code 4x "$code" && ok "Invalid restaurant path rejected ($code)" || bad "Invalid restaurant path accepted ($code)"

read -r code tmp < <(req GET "$BASE/restaurants/00000000-0000-0000-0000-000000000000")
expect_code 4x "$code" && ok "Unknown restaurant 404/4xx ($code)" || bad "Unknown restaurant not 4xx ($code)"

read -r code tmp < <(req POST "$BASE/reservations" '{
  "restaurant_id":"'"$RID"'",
  "party_size":2,
  "start":"'"$S1"'",
  "end":"'"$E1"'",
  "guest_name":"'"${NAME_PREFIX}BAD_TID"'",
  "guest_phone":"+1",
  "table_id":"00000000-0000-0000-0000-000000000000"
}')
expect_code 4x "$code" && ok "Unknown table_id rejected" || bad "Unknown table_id accepted ($code)"

### H. ADJACENCY (end == next start) ##########################################
sep "H. Adjacency on same table (end==start should be allowed)"
# pick a base slot and compute its immediate next slot from availability list
read -r code tmp < <(req GET "$BASE/restaurants/$RID/availability?date=$TEST_DATE&party_size=2")
if expect_code 200 "$code"; then
  B_S=$(cat "$tmp" | ${JQ_BIN} -r '.slots[0].start')
  B_E=$(cat "$tmp" | ${JQ_BIN} -r '.slots[0].end')
  B_T=$(cat "$tmp" | ${JQ_BIN} -r '.slots[0].available_table_ids[0]')
  N_S=$(cat "$tmp" | ${JQ_BIN} -r '.slots[1].start')
  N_E=$(cat "$tmp" | ${JQ_BIN} -r '.slots[1].end')
  if [[ "$B_E" == "$N_S" && "$B_T" != "null" ]]; then
    read -r c1 b1 < <(book "$B_T" "$B_S" "$B_E" 2 "${NAME_PREFIX}ADJ1")
    read -r c2 b2 < <(book "$B_T" "$N_S" "$N_E" 2 "${NAME_PREFIX}ADJ2")
    if expect_code 201 "$c1" && expect_code 201 "$c2"; then
      ok "Adjacency allowed (both bookings succeeded)"
    else
      bad "Adjacency failed (codes: $c1 then $c2)"
    fi
    # cleanup both
    for bb in "$b1" "$b2"; do
      rid=$(echo "$bb" | ${JQ_BIN} -r '.id // empty')
      [[ -n "$rid" ]] && read -r code tmp < <(req DELETE "$BASE/reservations/$rid") && expect_code 200 "$code" && ok "Cleaned adjacency id=$rid" || true
    done
  else
    ok "No adjacent slot in index [0..1] (skipping)"
  fi
else
  bad "Availability fetch for adjacency ($code)"
fi

### I. CONCURRENCY (two simultaneous posts) ###################################
sep "I. Concurrency: race same table/slot (only one should succeed)"
IFS=$'\t' read -r SR ER TR < <(first_slot_and_table_for_party 2)
if [[ -n "${SR:-}" && -n "${TR:-}" ]]; then
  # fire two in parallel
  RES_A="$(mktemp)"; RES_B="$(mktemp)"
  (book "$TR" "$SR" "$ER" 2 "${NAME_PREFIX}RACEA" > "$RES_A") &
  (book "$TR" "$SR" "$ER" 2 "${NAME_PREFIX}RACEB" > "$RES_B") &
  wait

  CA=$(cut -d' ' -f1 "$RES_A"); CB=$(cut -d' ' -f1 "$RES_B")
  if { expect_code 201 "$CA" && expect_code 4x "$CB"; } || { expect_code 4x "$CA" && expect_code 201 "$CB"; }; then
    ok "Race condition handled (one success, one reject)"
  else
    bad "Race condition NOT handled (codes: $CA, $CB)"
  fi

  # cleanup whichever succeeded
  for RFILE in "$RES_A" "$RES_B"; do
    C=$(cut -d' ' -f1 "$RFILE")
    BODY=$(cut -d' ' -f2- "$RFILE")
    if expect_code 201 "$C"; then
      rid=$(echo "$BODY" | ${JQ_BIN} -r '.id // empty')
      [[ -n "$rid" ]] && read -r code tmp < <(req DELETE "$BASE/reservations/$rid") && expect_code 200 "$code" && ok "Cleaned race id=$rid" || true
    fi
  done
else
  bad "Could not get slot/table for race test"
fi

### FINAL CLEANUP ##############################################################
sep "Z. Final cleanup"
cleanup_smoke_reservations

### SUMMARY ####################################################################
sep "SUMMARY"
echo "PASSED: $pass"
echo "FAILED: $fail"
[[ $fail -eq 0 ]] && exit 0 || exit 1

===== FILE: backend/full_regression.sh =====
#!/usr/bin/env bash
set -euo pipefail

# --- config ---
BASE="${BASE:-http://127.0.0.1:8000}"
RID="${RID:-fc34a984-0b39-4f0a-afa2-5b677c61f044}"
TID="${TID:-e5c360cf-31df-4276-841e-8cd720b5942c}"
DAY="${DAY:-$(date +%F)}"
TAG="RG-$(date +%s)"

need(){ command -v "$1" >/dev/null || { echo "need $1"; exit 1; }; }
need curl; need jq

ok(){ echo "$1"; }
die(){ echo "FAIL: $1" >&2; exit 1; }

# 0) server up
curl -fsS "$BASE/health" >/dev/null || die "backend not reachable at $BASE"

# 1) CORS preflight works (for mobile)
HDRS="$(curl -s -X OPTIONS "$BASE/reservations" \
  -H "Origin: http://example.com" \
  -H "Access-Control-Request-Method: POST" \
  -D - -o /dev/null)"
echo "$HDRS" | grep -qi "^access-control-allow-origin:" || die "CORS headers missing"
ok "[ok] CORS preflight allowed"

# 2) Baseline availability contains our table at 10:00
HAS="$(curl -fsS "$BASE/restaurants/$RID/availability?date=$DAY&party_size=2" \
  | jq -r --arg D "$DAY" --arg T "$TID" \
    ".slots[] | select(.start==(\$D+\"T10:00:00\")) | (.available_table_ids|index(\$T)!=null)")"
[ "$HAS" = true ] || die "table not free at baseline"
ok "[ok] baseline ok"

# 3) Create R1, ensure overlap blocked, create back-to-back R2, auto-pick R3
R1="$(
  jq -cn --arg r "$RID" --arg d "$DAY" --arg t "$TID" --arg g "$TAG-1" \
    '{restaurant_id:$r,party_size:2,start:($d+"T10:00:00"),end:($d+"T11:30:00"),guest_name:$g,table_id:$t}' \
  | curl -fsS -X POST "$BASE/reservations" -H "Content-Type: application/json" -d @- \
  | jq -r .id
)"
[ "$R1" != null ] && [ -n "$R1" ] || die "create R1"
ok "[ok] created $R1"

code="$(
  jq -cn --arg r "$RID" --arg d "$DAY" --arg t "$TID" --arg g "$TAG-ov" \
    '{restaurant_id:$r,party_size:2,start:($d+"T10:30:00"),end:($d+"T12:00:00"),guest_name:$g,table_id:$t}' \
  | curl -s -o /dev/null -w "%{http_code}" -X POST "$BASE/reservations" -H "Content-Type: application/json" -d @-
)"
[ "$code" = 409 ] || die "expected overlap=409, got $code"
ok "[ok] overlap blocked (409)"

R2="$(
  jq -cn --arg r "$RID" --arg d "$DAY" --arg t "$TID" --arg g "$TAG-2" \
    '{restaurant_id:$r,party_size:2,start:($d+"T11:30:00"),end:($d+"T13:00:00"),guest_name:$g,table_id:$t}' \
  | curl -fsS -X POST "$BASE/reservations" -H "Content-Type: application/json" -d @- \
  | jq -r .id
)"
[ "$R2" != null ] && [ -n "$R2" ] || die "create R2"
ok "[ok] created $R2 (back-to-back)"

R3="$(
  jq -cn --arg r "$RID" --arg d "$DAY" --arg g "$TAG-3" \
    '{restaurant_id:$r,party_size:2,start:($d+"T13:00:00"),end:($d+"T14:30:00"),guest_name:$g}' \
  | curl -fsS -X POST "$BASE/reservations" -H "Content-Type: application/json" -d @- \
  | jq -r .id
)"
[ "$R3" != null ] && [ -n "$R3" ] || die "create R3"
ok "[ok] auto-selected $R3"

# 4) Validation: missing date & bad date must be 422
curl -s -o /dev/null -w "%{http_code}" "$BASE/restaurants/$RID/availability?party_size=2" | grep -qx "422" \
  || die "missing date should be 422"
curl -s -o /dev/null -w "%{http_code}" "$BASE/restaurants/$RID/availability?date=BAD&party_size=2" | grep -qx "422" \
  || die "bad date should be 422"
ok "[ok] availability validates params"

# 5) Persistence across reload (simulate autoreload)
touch "$(dirname "$0")/app/storage.py" || true
sleep 2
curl -fsS "$BASE/reservations" \
  | jq -e --arg tag "$TAG" "(map(select(.guest_name|tostring|startswith(\$tag)))|length)>=3" >/dev/null \
  || die "persistence after reload"
ok "[ok] persisted after reload"

# 6) cancel -> idempotent -> confirm flow works
curl -fsS -X POST "$BASE/reservations/$R3/cancel"  >/dev/null || die "cancel 1"
curl -fsS -X POST "$BASE/reservations/$R3/cancel"  >/dev/null || die "cancel idempotent"
curl -fsS -X POST "$BASE/reservations/$R3/confirm" >/dev/null || die "confirm"
ok "[ok] cancel/confirm flow ok"

# 7) Cleanup only our 3
for id in "$R1" "$R2" "$R3"; do
  curl -s -o /dev/null -w "delete $id -> %{http_code}\n" -X DELETE "$BASE/reservations/$id" || true
done
curl -fsS "$BASE/reservations" \
  | jq -e --arg tag "$TAG" "(map(select(.guest_name|tostring|startswith(\$tag)))|length)==0" >/dev/null \
  || die "cleanup"
ok "[done] FULL REGRESSION GREEN"

===== FILE: backend/requirements.txt =====
# Core API
fastapi>=0.110,<1
uvicorn[standard]>=0.23,<1

# Pydantic v2 + settings (your code uses this)
pydantic>=2.7,<3
pydantic-settings>=2.0,<3
python-dotenv>=1.0,<2
